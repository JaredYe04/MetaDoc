{"merge.pdf_0":"UML建模技术 课程内容 •UML简介 •业务建模 •需求建模 •系统分析 •系统设计 2 第1章 UML简介 UML建模技术石秀金 3 1.1 建模的意义 •模型是对现实的简化，建模是为了更好地理解 系统。 –模型帮助我们按照实际情况或需求对系统可视化； –模型允许我们详细说明系统的结构、行为； –模型给出了一个构造系统的模板； –模型对我们作出的决策进行文档化； 4 1.2 建模的原理 选择创建什么模型对如何动手解决问题和如何形成 解决方案有意义深远的影响。 兔窝摩天大厦 5 1.2 建模的原理 •复杂的系统 6 1.2 建模的原理 •每一种模型可以在不同的精度级别上表示。 •最好的模型可以让你根据观察的角色及原因选择它 的详细程度。 7 Paper Airplane Fighter Jet 1.2 建模的原理 8  每一种模型可以在不同的精度级别上表示。 1.2 建模的原理 •对每个系统最好用一组几乎独立的模型去处理 9 1.3 选择UML •使用UML建立对象模型来映射现实世界 10 1.3 选择UML •UML—— Unified Modeling Language.","merge.pdf_1":"世界 10 1.3 选择UML •UML—— Unified Modeling Language. •Unified –组合了当前最好的面向对象软件建模方法 •1. OMT (James Rumbaugh) •2. The Booch method (Grady Booch) •3. OOSE (Ivar Jacobson) •Modeling –用于表达现实的简化视图，以便于面向对象软件系统的设 计与实现 •Language –UML主要是遵循精确语法的图形语言 11 1.3 选择UML •Grady Booch •Dr. Ivar Jacobson •Dr. James Rumbaugh 12 “3 amigos” （三友） 1.3 选择UML •统一的国际标 准建模语言 Unified Modeling Language 13 1.3 选择UML 14 Meyer Before and after conditions Harel Statecharts Gamma, et al Frameworks and patterns, HP Fusion","merge.pdf_2":"s Gamma, et al Frameworks and patterns, HP Fusion Operation descriptions and message numbering Embley Singleton classes and high-level view Wirfs-Brock Responsibilities Odell Classification Shlaer - Mellor Object lifecycles Rumbaugh OMT Booch Booch method Jacobson OOSE 1.3 选择UML 模型的种类模型的用途 业务模型对业务过程、工作流、组织的建模 需求模型对捕获的需求进行整理和分析的工具，辅助开发人员与用户进行 沟通 设计模型包含高层设计（架构模型）和详细设计模型，用于统一开发人员 、沟通设计信息 数据库模型设计数据库的结构、表结构以及与应用系统的交互 实现模型用来理清软件的组成、部署方案，为安装与维护人员的工作提供 指导 15 •可以建立什么模型 1.4 UML的历史 16 1.5 UML组成 17","merge.pdf_3":"员的工作提供 指导 15 •可以建立什么模型 1.4 UML的历史 16 1.5 UML组成 17 UML Structure 构造块 building blocks 公共机制 common mechanisms 规则 rules 基本 UML 建模元素、关系和图 达到特定目标的公共 UML 方法 系统架构的 UML 视图 1.5 UML组成 18 1.5.1 构造块 19 构造块 building blocks 事物 things 关系 relationships 图 diagrams 建模元素本身 关系把事物联系在一起，说明两个或多个事物时如何语义相关性的 UML 模型的视图，它们展现事物的集合，“讲述关于 软件系统的故事”，是我们可视化系统将做什么（分析 级图）或者系统如何做（设计级图）的方法 （1）事物 20 事物 Things 结构事物行为事物分组事物注解事物 UML 模型中的名词，如类、接口、协作、用例、活动类、组件、节点 UML 模型的动词，如交互、状态机 包，它用于把语义上相关的建模元素分组为内聚的单元 注解，它附加到模型以捕获特殊信息，同黄色便笺很相像 （2）关系","merge.pdf_4":"义上相关的建模元素分组为内聚的单元 注解，它附加到模型以捕获特殊信息，同黄色便笺很相像 （2）关系 21 关系 relationships 关联 association 依赖 dependency 泛化 generalization 实现 realization 描述对象 之间 的一组链接 物件的改变引起依赖物件的语义改变 一个元素是另一个元素的特化，而且它可以取代更一般的元素 类元之间的关系，一个类元说明一份契 约，另一个类元保证实现该契约 （2）关系 •关联（association） •泛化（generalization） •实现（realization） •依赖（dependency） 22 OR OR OR （3）图（UML1.4） 23 图 diagrams 类图 class diagrams 对象图 object diagrams 构件图 component diagrams 部署图 deployment diagrams 用例图 use case diagrams 顺序图 sequence` diagrams 协作图 collaboration diagrams 状态图","merge.pdf_5":"sequence` diagrams 协作图 collaboration diagrams 状态图 statechart diagrams 活动图 activity diagrams 静态模型 ( 系统结构 ) 动态模型 ( 系统行为 ) （3）图（UML1.4） •类 图：类以及类之间的相互关系 •对象图：对象以及对象之间相互关系 •构件图：构件及其相互依赖关系 •部署图：构件在各节点上的部署 •顺序图：强调时间顺序的交互图 •协作图：强调对象协作的交互图 •状态图：类所经历的各种状态 •活动图：对工作流建模 •用例图：需求捕获，测试依据 24 结 构 行 为 用例图 静态图 实现图 交互图 行为图 （3）图（UML2.0） 图名功能备注 类图描述类、类的特性以及类之间的关系 UML 1 原有 对象图描述一个时间点上系统中各个对象的一个快照 UML 1 非正式图 复合结构图 描述类的运行时刻的分解 UML 2.0 新增 构件图描述构件的结构与连接 UML 1 原有 部署图描述在各个节点上的部署 UML 1 原有 包图描述编译时的层次结构 UML 中非正式图","merge.pdf_6":"原有 部署图描述在各个节点上的部署 UML 1 原有 包图描述编译时的层次结构 UML 中非正式图 用例图描述用户与系统如何交互 UML 1 原有 活动图描述过程行为与并行行为 UML 1 原有 状态机图描述事件如何改变对象生命周期 UML 1 原有 顺序图描述对象之间的交互，重点在强调顺序 UML 1 原有 通信图描述对象之间的交互，重点在于连接 UML 1 中的协作图 计时图描述对象之间的交互，重点在于定时 UML 2.0 新增 交互纵览图 是一种顺序图与活动图的混合 UML 2.0 新增 25 用例图（use case diagram） •从外部视角描述系统做什么（并非怎样做），包含 了所有的场景（scenario ）。 26 学生 教务员 教授 维护选课计划 维护课程表 请求花名册 财务系统 学生注册系统 类图（class diagram） •描述类间关系 27 对象图（object diagram） •用具体实例描述类间关系，通常用来描述某些复杂 的关系。 28 polo : car frontleft : wheel frontright : wheel","merge.pdf_7":"8 polo : car frontleft : wheel frontright : wheel backleft : wheel backright : wheel car wheel n 11 n 顺序图（sequence diagram） •交互图的一种，强调对象间消息的时间顺序。 29 顺序图（sequence diagram） : 职 员 主 界 面 存 取 款 窗 口 账 户 存 款 记 录 / / 存 款 / / 新 建 存 取 款 窗 体 / / 显 示 存 取 款 窗 口 / / 存 款 / / 查 询 账 户 / / 创 建 存 款 记 录 / / 保 存 记 录 / / 计 算 账 户 余 额 / / 更 新 账 户 信 息 / / 存 款 注 销 存 取 款 窗 口 / / 完 成 存 款 通信图（Communication Diagram） •原1.ｘ中协作图，交互图的一种，强调对象的作用， 而非消息的时间顺序。 31 活动图（ Activity diagram） •描述某个过程的活动流程。 32 状态机图（ statemachine diagram）","merge.pdf_8":"ram） •描述某个过程的活动流程。 32 状态机图（ statemachine diagram） •描述对象可能的状态及其转换，关心对象在某过程 中的经历。 33 构件图（component diagram） •描述系统构件间的关系，关注软件的配置信息。 34 部署图（deployment diagram） •描述系统软硬件的配置信息。 35 包图 •包，是逻辑相关元素的集合。类放进包中可以简化 复杂的类图。 36 复合结构图 •表示类的内部结构 37 内部结构图 •复合结构图的一种。 38 协作图 •显示协作的定义。不属于UML2.0中十三张标准图。 39 交互纵览图 •混合活动图和顺序图 40 计时图 •一种特殊形式的顺序图。 41 1.5.2 公共机制 42 公共机制 common mechanisms 规格说明 specifications 修饰 adornments 公共分类 common divisions 扩展机制 extensibility mechanisms （1）规格说明 •UML模型至少具有两种维度： –图形维度：允许使用图和图标可视化模型","merge.pdf_9":"nisms （1）规格说明 •UML模型至少具有两种维度： –图形维度：允许使用图和图标可视化模型 –文本维度：由各种建模元素的规格说明所组成 •规格说明 –模型元素的特征和语义的文本描述—模型的“肉” 43 UC01: 预订房间 参与者： XXX 前置条件： XXX 基本事件流： 1.xxxxxxxxxxxxxx 2.xxxxxxxxxxxxxx 3.xxxxxxxxxxxxxx 扩展事件流 2a.xxxxxxxxxxxx ...... 后置条件： xxxxx UC02 ：登记入住 ...... 预订房间 登记入住 顾客 结帐离店 图形（可视化）视图 文字（规格描述）视图 –形成了承载模型的语义背板 （semantic backplane）， 赋予模型意义，各种图仅仅 是该背板的视图或者可视化 投影 –death by diagram—由于图 形而死亡 （2）修饰 •修饰：用来建模元素细节信息 –任何UML图仅是模型的视图，因此，只有在修饰增强了图 的整体清晰性和可读性或者突出模型的某些重要特征时， 你才应该表示那些修饰 44 （3）公共分类 •公共分类描述认识世界的特殊方法","merge.pdf_10":"型的某些重要特征时， 你才应该表示那些修饰 44 （3）公共分类 •公共分类描述认识世界的特殊方法 –类元（Classifier）和实例 •类：一类事物的抽象概念；如bank account –参与者、类、类元角色、组件、数据类型、接口、节点、信号、子系统、用 例 •实例：一类事物的特定实例；如my bank account –接口（interface）和实现 •接口：说明事物行为的契约（做什么） •实现：事物是如何工作的特殊细节（如何做） 45 Remote Sensor Remote Control Manufacturer Remote Control RemoteSensor <<interface>> Manufacturer （4）扩展机制 •构造型（stereotypes）： –基于已有的建模元素引入新的建模元素 46 actor <<Actor>> actor actor 《 exception 》 Overflow 《 exception 》 Overflow Overflow 构造型标准表示法 小图标表示法 新图标表示法 注：Overflow为类名 47","merge.pdf_11":"Overflow 构造型标准表示法 小图标表示法 新图标表示法 注：Overflow为类名 47 （4）扩展机制 •标记值（tagged value） –标记值则是用来为事物添加新特性的。标记值的表示方法 是用形如“{标记信息}”的字符串 –模型元素附加的命名信息，任何元素都可使用。 48 （4）扩展机制 •约束（constraint） –约束是用来增加新的语义或改变已存在规则的一种机制（自由文本和 OCL两种表示法）。 –约束的表示法和标记值法类似，都是使用花括号括起来的串来表示， 不过它是不能够放在元素中的，而是放在相关的元素附近 49 可见性规则标准 表示 Rose 属性 Rose 方法 public 任一元素，若能访问包容器，就可以访问它+ protected 只有包容器中元素或包容器后代才能够看到它# private 只有包容器中的元素才能够看得到它- package 只有声明在同一包中的元素才能够看到该元素~ 1.5.3 UML规则 •命名：也就是为事物、关系和图起名字。和任何语言一样， 名字都是一个标识符 •范围：与类的作用域相似，包括所有者作用域（owner","merge.pdf_12":"名字。和任何语言一样， 名字都是一个标识符 •范围：与类的作用域相似，包括所有者作用域（owner scope）和目标作用域（target scope）两类 •可见性： 1.5.4 架构 •Architecture –构架是一个系统的组织结构，包括系统分解成的 各个部分、它们的连接性、交互机制和通知系统 设计的向导规则 –IEEE：在其环境中系统的高级概念 50 （1）4+1视图 51 Process ViewDeployment View Logical View Use-Case View Implementation View End-user Functionality Programmers Software management Performance, scalability, throughput System integrators System topology, delivery, installation, communication System engineering Analysts/Designers Structure （1）4+1视图","merge.pdf_13":"engineering Analysts/Designers Structure （1）4+1视图 •Use Case View –End-user: Functionality –这些视图由用例视图所统一，它描述项目干系人 （stakeholder）的需求；所有其他视图都是从用例视图 派生而来，该视图把系统的基本需求捕获为用例并提供构 造其他视图的基础 •Logical View –Analysts/Designers: Structure –系统功能和词汇；描述问题域的词汇，作为类和对象的集 合。重点是展示对象和类是如何组成系统、实现所需系统 行为的 52 （1）4+1视图 Process View ◦System integrators: Performance, Scalability, Throughput ◦系统性能、可伸缩性和吞吐量；建模在我们系统中的可执行线程和进程 作为活动类。其实，它是逻辑视图面向进程的变体，包含所有相同的制 品 Implementation View ◦Programmers: Software Management","merge.pdf_14":"ementation View ◦Programmers: Software Management ◦系统组装和配置管理；对组成基于系统的物理代码的文件和组件进行建 模。它同样展示出组件之间的依赖，展示一组组件的配置管理以定义系 统的版本 Deployment View ◦System engineering: System Topology, Delivery, Installation, Communication ◦系统的拓扑结构、分布、移交和安装；建模把组件物理地部署到一组物 理的、可计算节点上，如计算机和外设上。它允许你建模横跨分布式系 统节点上的组件的分布 53 （2）视图 主要领域视图图 结构静态视图类图 设计视图复合结构图、协作图、构件图 用例视图用例图 动态状态视图状态机图 活动视图活动图 交互视图顺序图、通信图 物理部署视图部署图 模型管理模型管理视图 包图 特性描述包图 54 （3）UML建模工具 •IBM Rational Rose •IBM Rational Software Modeler •IBM Rational Software Architect","merge.pdf_15":"Software Modeler •IBM Rational Software Architect •Borland Together •Microsoft Visio •Sybase PowerDesigner •...... 55 1.6 UML的特点 •统一的标准 •面向对象 •可视化，表示能力强 •跟过程无关 •易于学习使用 56 理解 •UML是一种语言 –遵循特定的规则 –允许创建各种模型 –并不告诉设计者需要创建哪些模型 –并不提供开发过程 •UML是可视化语言 –UML是图形化语言 –图形便于交流（一幅图抵上千文字） 57 理解 •UML是用于构造系统或理解系统的语言 –UML既支持正向工程，又支持反向工程 •UML是文档化语言 –将所建造的系统记录下来 –便于新程序员跟进 –开发产品新版本时很有用处 58 误区 •UML是一种方法论？ –只是规范、标准，没有方法指南，只有方法的概念 •UML是一堆图形？ –还有文字 •UML只能应用与面向对象开发？ –还可以建模业务、数据库、工作流等等 •UML是Rational Rose里的建模符号？","merge.pdf_16":"象开发？ –还可以建模业务、数据库、工作流等等 •UML是Rational Rose里的建模符号？ –Rational Rose只是其中一种建模工具。 59 UML建模技术 第2章 业务建模 UML建模技术石秀金 2.1 业务建模意义 •作用： –帮助了解机构及其软件系统（或工作内容）； –帮助业务过程重建工程工作； –帮助员工（小组内成员）充分了解业务及其角色。 •什么时候需要？ –对机构不熟悉； –机构业务发生变更； –机构中主要部分使用的软件需建立； –机构中有些大型复杂工作流的文档不足。 62 2.2 明确项目愿景 •项目愿景是客户建设系统的最终愿望 –为什么要建设这个系统？ –建设这个系统要达到什么目的？ •了解以下内容，辅助明确愿景 –业务概况 –业务目标 –人员情况 –预算要求 –工时要求 •愿景特性：易于捕获，而极少变化 2.2 明确项目愿景 •以文档形式固化项目 愿景。 •项目愿景的最佳格式 是通过新建系统“为 谁提供什么样的服务 ”或者是“满足谁什 么样的愿望” •但我们往往是从项目 招标书中，将项目建 设目标直接摘出，作 为项目愿景。 要与项目目标、计划、建设","merge.pdf_17":"但我们往往是从项目 招标书中，将项目建 设目标直接摘出，作 为项目愿景。 要与项目目标、计划、建设 目标、计划相区分 2.3 涉众分析 •涉众是与要建设的项目相关的一切人和事，这些人或事应该 是关注项目愿景，并对项目有明确的期望，项目愿景是否能 达成会影响到其利益。 –税务局是不是涉众？ •一般从以下几个方面去查找涉众： –项目投资方 –项目使用者 –项目规划者 –项目管理者 •两个原则： –一是涉众是有明确期望的，二是涉众期望是独特的。 2.3 涉众分析 •由项目愿景做进一步的访谈也可得到涉众 –对客户关系价值进行统计分析，为公司进一步挖掘客户价 值提供数据支持 涉众期望不能明 确采集时由其它 相关涉众推演 2.3 涉众分析 •涉众分析最重要的是找出涉众的期望，期望一定是 与项目愿景一致 –供货商期望多付款？ –员工期望任意采购？ –领导期望收入增加？ –客户期望不付款？ 2.3 涉众分析 •涉众分析报告可以包括涉众概要、涉众简档等内容 –涉众概要包括涉众名称、涉众说明、涉众期望等 –涉众简档包括涉众名称、涉众代表、特点、职责、成功标 准、意见等 •验证：","merge.pdf_18":"、涉众说明、涉众期望等 –涉众简档包括涉众名称、涉众代表、特点、职责、成功标 准、意见等 •验证： –每一个项目愿景至少由一个涉众去体现 –每一个涉众至少属于一个项目愿景 2.3 涉众分析 系统满足什么的期望 是否为预期使用者，操作 频率和操作水平如何 在业务系统中要做 的事情 2.3 涉众分析 •划分优先级： –业务愿景优先级 –涉众优先级 –涉众期望优先级 •根据优先级制订需求调研计划 2.4 确定业务活动者 •业务活动者一定是一项完整业务的主动发起者 –业务要处理的事务创建时为业务起始，处理完事务为业务 结束。 –业务主角来源于涉众，从中找出满足上述条件的涉众，升 级为业务活动者，这个涉众应该是系统的预期使用者。 –很多情况下业务的内容就决定了谁是业务活动者。 •验证： –一个业务活动者至少代为行使一个涉众的期望； –一个涉众的期望至少有一个业务主角代为行使； 2.4 确定业务活动者 •区分： –业务 活动者（Business Actor） •机构（组织）外部参与者 –业务工人（Business Worker） •机构内部参与者所起作用的表示","merge.pdf_19":"构（组织）外部参与者 –业务工人（Business Worker） •机构内部参与者所起作用的表示 –业务机构（Business Organization） •机构的组织部门 ，业务元素的集合； –物理工人（Phsical Worker） •机构内部人类参与者 2.5 确定业务用例 •将每个业务活动者（涉众）的期望建模成业务用例 跟踪客户挖掘机会 销售人员 跟踪合同执行情况 2.6 绘制业务用例图 •可以先为每个业务活动者单独绘制一张业务用例图 ，避免遗漏，后期再合并 74 企业客户 信用系统 值勤 警卫系统 保安 运钞 运钞车 兑换钞票 银行职员 贷款业务 信用卡业务 存、取款业务 理财业务 银行客户 外汇业务 个人客户 2.7 撰写业务用例规约 •采购业务流程： 1. 员工提交采购申请给部门经理； 2. 部门经理审批员工采购申请单； 3. 部门经理将已审批通过的采购申请单合并后提交给经营 服务部； 4. 经营服务部审批部门采购申请单，商务同时询价并选择 供应商签订合同； 5. 供应商按合同要求送货； 6. 经营服务部将物品发送至部门经理； 7. 部门经理通知员工； 8.","merge.pdf_20":". 供应商按合同要求送货； 6. 经营服务部将物品发送至部门经理； 7. 部门经理通知员工； 8. 员工领取物品。 2.8 使用活动图建模业务流程 公司各部门商务经营服务部经理总经理财务部 一次采购可能 生成多个合同 [是] [否] [是] [是] [是] 提出采购申请询价 签订并登记合同 接收合同 维护发票信息接收/核实发票信息 生成合同、非合同 审核 是否合同 审核非合同审核合同 总经理审核 UML建模技术 第3章 需求建模（用例建模） UML建模技术石秀金 78 案例背景：课程注册系统 •课程注册系统 –将为学生提供在线课程注册的服务。课程注册系统可以让 教授选择其要讲授的课程并保存学生的成绩。 –同现有的课程目录数据库结合起来使用。 –新系统将提供两种方式让所有的教授和学生访问系统： •将个人计算机连接到 Wylie College 计算机网络以及连接到 Internet。 案例背景：课程注册系统 •登录 –学生、教授和课程注册员都必须提供有效的 ID 和口令才能进入课程 注册系统。当用户申请进入学院时，他们将得到 ID 和临时口令。系 统应允许用户修改他们的临时口令。","merge.pdf_21":"注册系统。当用户申请进入学院时，他们将得到 ID 和临时口令。系 统应允许用户修改他们的临时口令。 •课程注册 –系统根据学生的请求向学生显示可选的课程。学生应可以根据课程名 称、课程代码和所在系来对课程进行查询。系统将接受学生的课程注 册，并根据课程的开设情况、课程表冲突和完成必修课程等情况来进 行核实。如果课程注册没有成功，那么系统应立即通知学生。 –在注册期结束以前，系统应允许学生更改课程选择。 •课程取消 –系统应允许注册员取消课程。通常，注册员在注册期结束前检查所有 的课程，并取消那些没有任课教师或者选课人数少于 3 人的课程。课 程注册员通过电话或邮件通知选择了被取消课程的学生。 案例背景：课程注册系统 •学生收费 –在注册期结束后，系统将给收费系统发出通知。这些通知应包括学生 姓名、地址、所选课程和收费金额。 •输入、更新和查看教授信息 –系统应接受和更新教授信息，包括姓名、地址、电话、传真和电子邮 件地址。教授信息应能够让教授和课程注册员查看。 •查看学生成绩 –系统应允许学生查看某门课程的成绩或全部的成绩报告单。同时，系","merge.pdf_22":"和课程注册员查看。 •查看学生成绩 –系统应允许学生查看某门课程的成绩或全部的成绩报告单。同时，系 统应保护学生的成绩信息，除了学生本人和教授以外的其他用户不能 访问这些信息。 •选择要讲授的课程 –系统应使教授能够在注册期结束前登记要讲授的课程。 案例背景：课程注册系统 •输入、更新和查看学生信息 –系统应接受和更新学生信息，包括学生的 ID、姓名、地址、电话、和 电子邮件地址。学生信息应能够让教授和课程注册员查看。系统应确 保学生只能访问他（她）本人的信息。注册员维护学生信息。 •记录学生成绩 –系统应接受、确认和保留教授输入的学生成绩。 •查看课程目录信息 –保存在课程目录数据库中的课程目录信息应根据用户的请求显示给用 户。用户可以根据课程名称、课程代码、教授姓名和所在系来查询课 程信息。 •查看课程表 –系统应根据学生的请求显示该学生全部课程的时间安排。 •监控课程是否满员 –系统应确保没有一门课程选修的学生人数超过 10 名。 3.1 用例模型 83 补充规约 术语表 用例规约 ... Use-Case Model 活动者 用例 活动者 3.1 用例建模 •五步：","merge.pdf_23":"用例规约 ... Use-Case Model 活动者 用例 活动者 3.1 用例建模 •五步： •1）绘制用例图（图形化建模系统需求） •2）撰写用例规约（用文字细化系统需求） •3）用活动图建模业务流程 •4）定义词汇表（术语表) •5）撰写补充规约 3.2 用例图 •组成 –用例（Use Case） –活动者（角色，Actor） –关系（Relationship） 85 管理员 学生记录管理 3.2.1 活动者 •Actor –系统外部的参与者，可以是人、外部硬件、其他系统，甚 至时间。 86 actor <<Actor>> actor actor 学生财务系统时间 3.2.1 活动者 •理解： –Actor不是指人，而是指代表某一种特定功能的角色，因 此同一个人可能对应很多个Actor。Actor是虚拟的概念， 可以指外部系统和设备。 –如果一个角色的操作是由另外一个角色代理完成的，请建 立该角色到另外角色的依赖。 87 3.2.1 活动者（角色） •怎样识别活动者？ –谁向系统提供信息？ –谁从系统获取（使用）信息？ –谁操作系统？ –谁维护系统？ –系统使用哪些外部资源？","merge.pdf_24":"提供信息？ –谁从系统获取（使用）信息？ –谁操作系统？ –谁维护系统？ –系统使用哪些外部资源？ –系统是否和已经存在的系统交互？ –是否有事情自动在预计时间发生？ 88 3.2.2 用例 •Use Case: –系统、子系统或类与外部的参与者（actor）交互 的动作序列的说明，包括各种序列及出错序列。 –用例分析可以认为是对系统功能的分解。 89 登录 90 3.2.2 用例 •场景 91 3.2.2 用例 •怎样确定用例的粒度？ –用例的粒度（用例的大小）可大可小，一般一个系统宜控 制在20个用例左右。 –用例是系统级的、抽象的描述，不是细化的（是做什么， 非怎样做） –对复杂的系统可以划分为若干子系统处理。 学籍处理 退学处分 92 3.2.2 用例 •CRUD 用例 –Create, Read, Update, 或者 Delete 用例 •不要混淆用例和功能 Create a schedule Read a schedule Update a schedule Delete a schedule Register for courses 3.2.2 用例 •怎样获取用例？","merge.pdf_25":"a schedule Register for courses 3.2.2 用例 •怎样获取用例？ –活动者希望系统执行什么任务？ –活动者在系统中访问哪些信息（创建、存储、修 改、删除等）？ –需要将外界的哪些信息提供给系统？ –需要将系统的哪个事件告诉活动者？ –如何维护系统？ 93 3.2.3 关系 •关联（association） •包含（include） •扩展（extend） •泛化（generalization） 94 （1）关联association •用单向箭头表示，只表示谁启动用例，不考虑信息 的双向流动；每个用例都有角色启动，除包含和扩 展用例 •无论用例和角色是否存在双向数据交流，关联总是 由角色指向用例。 95 管理员 学生记录管理 （1）关联association •每一个关联都代表了一段对话 96 （2）包含include •箭头方向由基本用例指向被包含用例； •两个以上用例有共同功能，可分解到单独用例，形 成包含依赖； •执行基用例时，每次都必须调用被包含用例，被包 含用例也可单独执行； 97 取消订单 客户 查询订单 <<include>> 98","merge.pdf_26":"包含用例，被包 含用例也可单独执行； 97 取消订单 客户 查询订单 <<include>> 98 （2）包含include •包含include –一个用例过于复杂，可以分解成小用例，构成包含依赖（ 三个被包含的用例合起来实现完整的事件流，不能单独调 用）； 付费 提供客户数据 订购产品 顾客 网上购物 <<include>> <<include>> <<include>> （3）扩展extend •一个用例（在某些扩展点上）扩展另一个用例的功 能 ，构成新用例； •扩展用例依赖于被扩展依赖（基本用例），只是部 分片断组成，不是完整的独立用例，无法单独执行； 99 查看教授信息 学生 注册课程 <<extend>> （4）泛化（generalization） •一个用例和其几种情形的用例间构成泛化。 •往往父用例表示为抽象用例（abstract）。 100 现金支付 付费 信用卡支付 帐号密码验证 登录验证 指纹验证 数字签名验证 3.2.4 绘制用例图 •显示系统和外部实 体交互的图。 101 课程注册系统 Course Catalog View Report Card","merge.pdf_27":"体交互的图。 101 课程注册系统 Course Catalog View Report Card Register for Courses Submit Grades Select Courses to Teach Student Professor Maintain Student Information Maintain Professor Information Login Billing System Registrar Close Registration 3.2.4 绘制用例图 102 103 3.2.4 绘制用例图 •Rational Software Modeler 104 3.2.4 绘制用例图 3.2.5 常见错误 •错误： _录单员 (from _公共角色) _运单 (from _公共角色) 录入运单数据 接收受理单 受理单 (from _公共角色) 3.2.5 常见错误 •错误：CRUD 用例 –Create, Read, Update, 或者 Delete 用例 •不要混淆用例和功能 106 Create a schedule Read a schedule","merge.pdf_28":"•不要混淆用例和功能 106 Create a schedule Read a schedule Update a schedule Delete a schedule Register for courses 3.2.5 常见错误 •错误： _扫描员 自动记录运单号 记入数据库 扫描运单 3.2.5 常见错误 108 109 3.2.5 常见错误 更新项目 删除项目 添加项目 项目管理员 管理项目 <<extend>> <<extend>> <<extend>> 更新项目 删除项目 添加项目 项目管理员 管理项目 更新项目 删除项目 添加项目 项目管理员 管理项目 <<include>> <<include>> <<include>> VS 3.2.5 常见错误 •Visio的错误 3.2.5 常见错误 •Visio的错误 3.3 用例规约 •用例模型不仅仅是图形 3.3 用例规约 •更详细地描述用例的功能 •主要组成： –用例名称 –简要说明/描述 –优先级 –参与者 –前提条件 –主事件流 –其他事件流 –扩展点 –后置条件 113","merge.pdf_29":"说明/描述 –优先级 –参与者 –前提条件 –主事件流 –其他事件流 –扩展点 –后置条件 113 Use-Case Specifications ... Use-Case Model Actors Use Cases 3.3 用例规约 •用例描述模板 114 用例编号 [为用例制定一个唯一的编号，通常格式为UCxx] 用例名称 [应为一个动词短语，让读者一目了然地知道用例的目标] 用例概述 [用例的目标，一个概要性的描述] 范围 [用例的设计范围] 主参与者 [该用例的主Actor，在此列出名称，并简要的描述它] 次要参与者 [该用例的次要Actor，在此列出名称，并简要的描述它] 项目相关人 利益说明 项目相关人利益 [项目相关人员名称] [从该用例获取的利益] ............ 3.3 用例规约 •用例描述模板（续） 115 前置条件 [即启动该用例所应该满足的条件。] 后置条件 [即该用例完成之后，将执行什么动作。] 成功保证 [描述当前目标完成后，环境变化情况。] 基本事件流步骤 活动 1 [在这里写出触发事件到目标完成以及清除的步骤。] 2","merge.pdf_30":"，环境变化情况。] 基本事件流步骤 活动 1 [在这里写出触发事件到目标完成以及清除的步骤。] 2 ......(其中可以包含子事件流，以子事件流编号来表示) 扩展事件流 1a [1a表示是对1的扩展，其中应说明条件和活动] 1b ......(其中可以包含子事件流，以子事件流编号来表示) 子事件流 [对多次重复的事件流可以定义为子事件流，这也是抽 取被包含用例的地方。] 规则与约束 [对该用例实现时需要考虑的业务规则、非功能需求、 设计约束等] 3.3 用例规约 •登录 •选修课程 •查看成绩 •选教课程 •提交成绩 •维护学生信息 •维护教授信息 •关闭选课 116 课程注册系统 3.3 用例规约 •登录 •选修课程 •查看成绩 •选教课程 •提交成绩 •维护学生信息 •维护教授信息 •关闭选课 117 课程注册系统 3.3 用例规约 •登录 •选修课程 •查看成绩 •选教课程 •提交成绩 •维护学生信息 •维护教授信息 •关闭选课 118 课程注册系统 3.4 活动图 •Activity Diagram –建模业务流程 –建模算法流程 3.4 活动图","merge.pdf_31":"3.4 活动图 •Activity Diagram –建模业务流程 –建模算法流程 3.4 活动图 •活动图和交互图是UML中对系统动态方面建模的两 种主要形式 –交互图强调的是对象到对象的控制流，而活动图则强调的 是从活动到活动的控制流 –活动图是一种表述过程基理、业务过程以及工作流的技术 。它可以用来对业务过程、工作流建模，也可以对用例实 现甚至是程序实现来建模 3.4.1 组成元素 •活动 •决策 •转换 •同步 •泳道(分区) •对象流 •信号发送和接收 •引脚 121 3.4.1 组成元素 122 Activity/Action Synchronization Bar (Fork) Guard Condition Synchronization Bar (Join) Decision Concurrent Threads Transition Select Course [ add course ] Check Schedule Check Pre-requisites Assign to Course Resolve Conflicts Update Schedule","merge.pdf_32":"ssign to Course Resolve Conflicts Update Schedule Delete Course [ checks completed ][ checks failed ] [ delete course ] 3.4.2活动 •Activity –表示工作流中任务的执行或者职责。 –也可以表示过程（procedure）中语句的执行。 •初始节点和活动终点 –用一个实心圆表示初始节点，用一个圆圈内加一个实心圆 来表示活动终点 •活动节点 –是活动图中最主要的元素之一，它用来表示一个活动 123 3.4.3 转换 •Transition –当一个活动结束时，控制 流就会马上传递给下一个 活动节点，在活动图中称 之为“转换”，用一条带 箭头的直线来表示 124 3.4.4 决策 •Decision –根据不同的分支，转向不同的 活动，每个转移是一个分支。 –用菱形表示的，它有一个进入 转换， 一个或多个离开转换。而每个 离开转换上都会 有一个监护条件，用来表示满 足什么 条件的时候执行该转换。 125 enter PIN verify P IN","merge.pdf_33":"件，用来表示满 足什么 条件的时候执行该转换。 125 enter PIN verify P IN [ incorrect ] continue [ correct ] 3.4.5 同步 •Synchronizations –用来建模并发活动。 –包含分叉（fork）和汇合（join）。 126 接到会议通知 安排行程 准备发言稿 参加会议 返回 接到会议通知 安排行程 准备发言稿 参加会议返回 3.4.6 泳道（分区） •Swimlanes （ Partitions ） –用来将活动分组， 显示活动的负责 者。 –一个泳道显示一 个活动轨迹。 127 3.4.7 对象流 •Object Flow –用来描述活动和活动所创建的（输出）或所使用（输入） 的对象之间的关系。 128 付款 账单 [已付] 2025/5/28Copy Right X.Shi,DHU129 3.4.7 对象流 •对象流和转换 活动1 活动2 对象 [状态] 不用这个 转换 2025/5/28Copy Right X.Shi,DHU130 6、对象流 •带对象流的活动图 3.4.7 对象流 •带对象流的活动图","merge.pdf_34":"X.Shi,DHU130 6、对象流 •带对象流的活动图 3.4.7 对象流 •带对象流的活动图 131 3.4.8 信号发送和接收 •发送信号与接收信号： 132 3.4.9 引脚 •Pin –是一个对象节点，代表活动连接输入、输出值的连接点 –用来标明每个活动节点所需输入的数据或者所产生的数据 （建模业务流时则可表示产生或者消耗的资源） 133 3.4.10 扩展区 •Expansion region –表重复或循环 134 3.4.11 辅助活动图 •当活动图过于复杂时可以用 135 3.4.12 绘制活动图 •绘制时首先决定是否采用泳道：主要根据活动图中 是否要体现出活动的不同实施者 •然后尽量使用分支、分岔和汇合等基本的建模元素 来描述活动控制流程 •如果需要，加入对象流以及对象的状态变化，利用 一些高级的建模元素（如辅助活动图、汇合描述、 发送信号与接收信号、引脚、扩展区）来表示更多 的信息 •活动图的建模关键是表示出控制流，其它的建模元 素都是围绕这一宗旨所进行的补充 136 3.4.12 绘制活动图 •业务流 137 Select Course Check","merge.pdf_35":"的补充 136 3.4.12 绘制活动图 •业务流 137 Select Course Check Schedule Check Pre-requisites Assign to Course Resolve Conflicts Update Schedule Delete Course [ checks completed ] [ checks failed ] [ delete course ] 2025/5/28Copy Right X.Shi,DHU138 3.4.12 绘制活动图 •用于业务建模的时候，每一条泳道表示一个职责单位，该图能够有效地体现出所有 职责单位之间的工作职责，业务范围及之间的交互关系、信息流程 •建模策略： –为工作流建立一个焦点，除非你所涉及的系统很小，否则不可能在一张图中显示出系统中所有 的控制流 –选择对全部工作流中的一部分有高层职责的业务对象，并为每个重要的业务对象创建一条泳道 –识别工作流初始节点的前置条件和活动终 点的后置条件，这可有效地实现对工作流 的边界进行建模。 2025/5/28Copy Right X.Shi,DHU139","merge.pdf_36":"地实现对工作流 的边界进行建模。 2025/5/28Copy Right X.Shi,DHU139 3.4.12 绘制活动图 •工作流建模建模策略（续）： –从该工作流的初始节点开始，说明随时间发生的动作和活动，并在活动图中把它们表示成活动 节点 –将复杂的活动或多次出现的活动集合归到一个活动节点，并通过辅助活动图或子活动图来表示 它们 –找出连接这些活动节点的转换，首先从工作流的顺序开始，然后考虑分支，接着再考虑分岔和 汇合 –如果工作流中涉及重要的对象，则也可以将它们加入到活动图中 –若工作流中有多次启用的，则可采用 展开区表示 2025/5/28Copy Right X.Shi,DHU140 4.3.1 工作流建模 •业务流 需求产品 收货 付款 ｂ : 账单 [已 付] 处 理订单 o : 订单 [订单处理] 结账 ｂ : 账单 [未付] 结 束订单 o : 订单 [已发货] 配货 送货 3.4.12 绘制活动图 •借阅图书活动图如下： 2025/5/28Copy Right X.Shi,DHU141 2025/5/28Copy Right X.Shi,DHU142","merge.pdf_37":"ght X.Shi,DHU141 2025/5/28Copy Right X.Shi,DHU142 3.4.12 绘制活动图 •4.3.2 操作建模 –每一个对象占据一个泳道，而活动则是该对象的成员方法 –建模策略： •收集操作所涉及的抽象概念，包括操作的参数、返回类型、所属类的属性以及某些邻近的类 •识别该操作的初始节点的前置条件和活动终点的后置条件。也要识别在操作执行过程中必须保持的信 息 •从该操作的初始节点开始，说明随着时间发生的活动，并在活动图中将它们表示为活动节点 •如果需要，使用分支来说明条件语句及循环语句 •仅当这个操作属于一个主动类时，才在必要时用分岔和汇合来说明并行的控制流程 143 4.3.2 操作建模 t=0;i=1 j=0 t=a[ j] a[j]=a[j+1] a[j] =t j++ i++ [ j > = 1 0 - i ] [ j < 1 0 - i ] [ a [ j ] < a [ j + 1 ] ] [ a [ j ] > = a [ j + 1 ] ] [ i < 1 0 ] [ i > = 1 0 ] 3.5 词汇表 Glossary","merge.pdf_38":"1 ] ] [ i < 1 0 ] [ i > = 1 0 ] 3.5 词汇表 Glossary 词汇表主要用于 定义项目特定的 术语，它有助于 开发人员对项目 中所用的术语有 统一的理解和使 用，它也是后续 阶段中进行对象 抽象的基础。 144 课程注册系统 3.6 补充规约 •Supplementary Specification –补充规约记录那些在用例模型中不易表述的系统需求，主 要包括以下内容以下几类： •功能性 •可用性 •可靠性 •性能 •可支持性 •设计约束 145 Supplementary Specification 3.6 补充规约 •功能性 –功能性需求主要在用例模型中刻画，但是也有部分需求不 适合在用例中表述。有些功能性需求是全局性的，适用于 所有的用例，如出错处理、I18N支持等，我们不需要在所 有的用例中描述这些功能性需求，只需要在补充规约中统 一描述就可以了。 •可用性 –记录所有可用性相关的需求，如系统的使用者所需要的培 训时间、是否应附合一些常见的可用性标准如Windows界 面风格等。 146 3.6 补充规约 •可靠性","merge.pdf_39":"、是否应附合一些常见的可用性标准如Windows界 面风格等。 146 3.6 补充规约 •可靠性 –定义系统可靠性相关的各种指标，包括： •可用性：指出可用时间百分比(xx.xx%)，系统处于使用、维护、降 级模式等操作的小时数； •平均故障间隔时间(MTBF)：通常表示为小时数，但也可表示为天 数、月数或年数； •平均修复时间(MTTR)：系统在发生故障后可以暂停运行的时间； •精确度：指出系统输出要求具备的精密度（分辨率）和精确度 （按照某一已知的标准）； •最高错误或缺陷率：通常表示为bugs/KLOC（每千行代码的错误 数目）或bugs/function-point（每个功能点的错误数目）。 147 3.6 补充规约 •性能 –记录系统性能相关的各种指标，包括： •对事务的响应时间（平均、最长）； •吞吐量（例如每秒处理的事务数）； •容量（例如系统可以容纳的客户或事务数）； •降级模式（当系统以某种形式降级时可接受的运行模式）； •资源利用情况：内存、磁盘、通信等。 148 3.6 补充规约 •可支持性 –定义所有与系统的可支持性或可维护性相关的需求，其中","merge.pdf_40":"信等。 148 3.6 补充规约 •可支持性 –定义所有与系统的可支持性或可维护性相关的需求，其中 包括编码标准、命名约定、类库、如何来对系统进行维护 操作和相应的维护实用工具等。 •设计约束 –设计约束代表已经批准并必须遵循的设计决定，其中包括 软件开发流程、开发工具、系统构架、编程语言、第三方 构件类库、运行平台和数据库系统等等。 149 3.6 补充规约 1、功能 本节列出了多个用例所共有的功能性需求。 系统错误记录 所有的系统错误都应当记录下来。系统的致命错误会导致系统 的有序关闭。 系统错误消息应包括错误的文本说明、操作系统的错误代码（ 如果适用于该错误）、检测错误状态的模块、数据戳和时间戳 。所有的系统错误都应保存在错误日志数据库中。 远程访问 通过 Internet 连接，可以远程使用所有的功能。这可能需要应 用程序或控制器在远程计算机上运行。 课程注册系统 3.6 补充规约 2、可用性 本节列出了所有那些涉及到或影响到系统可用性的需求。 Windows 兼容性 桌面用户界面应与 Windows 95/98 兼容。 易于使用的设计","merge.pdf_41":"求。 Windows 兼容性 桌面用户界面应与 Windows 95/98 兼容。 易于使用的设计 课程注册系统用户界面的设计应当着眼于易于使用，使具有一 定计算机知识的用户群体不需要经过更多的培训就能够使用系 统。 联机帮助 课程注册系统的每项特性都应具有内置的用户联机帮助。联机 帮助应包括关于系统使用的分步指导。联机帮助应包括术语和 缩写词的定义 课程注册系统 3.6 补充规约 3、 可靠性 本节列出了所有的可靠性需求。 可用性 课程注册系统在每周七天，每天二十四小时内都应是 可以使用的。宕机的时间应少于 4%。 平均故障间隔时间 平均故障间隔时间应超过三百小时。 课程注册系统 3.6 补充规约 4、性能 本节概述了系统的性能特征。 同时在线的用户数 在任意既定时刻，系统最多可支持 2000 名用户同时使用中央 数据库，并在任意时刻最多可支持 500 名用户同时使用本地服 务器。 数据库访问响应时间 系统将能在十秒钟内提供对遗留课程目录数据库的访问。 事务响应时间 系统必须能够在 2 分钟内完成所有事务的 80%。 课程注册系统 3.6 补充规约 5、可支持性","merge.pdf_42":"系统必须能够在 2 分钟内完成所有事务的 80%。 课程注册系统 3.6 补充规约 5、可支持性 本节定义了将提高正在构建的系统的可支持性和可维护性的需 求。 可下载的新发布版 课程注册系统的 PC 客户机程序部分的升级可以通过 Internet 从 UNIX 服务器上下载。此功能可以让学生很容易地对系统进 行升级。 6、设计约束 本节列出了正在构建系统的设计约束。 遗留的课程目录系统 该系统应与在 College DEC VAX 主框架上运行的现有遗留系统 （课程目录数据库）集成在一起。 课程注册系统 3.6 补充规约 6、设计约束（续） 收费系统 课程注册系统应与在 College DEC VAX 主框架上运行的现有课程收费系统 交互。 平台需求 课程注册系统的客户机程序应运行于具有 486 处理器或更高配置的个人电脑 上。客户机程序运行要求的磁盘空间不到 20 MB，并且内存为 32 MB。 课程注册系统的服务器部分应运行在 Wylie College UNIX 服务器上。 Internet 浏览器","merge.pdf_43":"统的服务器部分应运行在 Wylie College UNIX 服务器上。 Internet 浏览器 课程注册系统的基于 Web 页的界面应在 Netscape 4.0.4 和 Internet Explorer 4.0 浏览器中运行。 Java 兼容性 基于 Web 页的界面应和 Java 1.1 VM 运行环境相兼容。 课程注册系统 UML建模技术 第4章 系统分析（用例分析） UML建模技术石秀金 157 4.1 步骤 •用协作建模用例实现 •用类图（分析级）分析对象行为 •用顺序图（分析级）建模用例行为 •用通信图（分析级）建模用例行为 •用交互纵览图细化活动细节(可选) •丰富类图 •描述分析机制 158 4.2 用协作建模用例实现 •协作图 –显示协作的定义。不属于UML2.0中十三张标准图。 159 4.2 用协作建模用例实现 •建模用例实现 160 Class Diagrams Use Case Communication Diagrams Use CaseUse-Case Realization Sequence Diagrams 4.2 用协作建模用例实现","merge.pdf_44":"-Case Realization Sequence Diagrams 4.2 用协作建模用例实现 •迭代的过程 161 Iteration n Iteration n + 1 Use Case A Scenarios 1 & 2 Use-Case Realization A 开始迭代 结束迭代 Use Case B Scenario 1 Use-Case Realization A Use Case A Scenario 3 Use-Case Realization B 4.2 用协作建模用例实现 Register for Courses <<use-case realization>> (from Use-Case Realization - Register for Courses) Register for Courses (from Use Case View) Login <<use-case realization>> (from Use-Case Realization - Login) Login (from Use Case View)","merge.pdf_45":"e Realization - Login) Login (from Use Case View) Close Registration <<use-case realization>> (from Use-Case Realization - Close Registration) Close Registration (from Use Case View) 课程注册系统 4.3 用类图（分析级）分析对象行为 •制品 163 补充规格说明 术语表 Use-Case 分析 项目规范指南 用例实现 分析模型 用例模型 分析类 架构文档 4.3.1 类 •类由水平线分割为三个部分 类名称 属性 操作 Student -name:String -major:int +register(Lesson):void +showReg():void + 表示 public - 表示 private # 表示 protected shape origin : point size : double fillcolor : color count : int other","merge.pdf_46":"size : double fillcolor : color count : int other <<constustor>> shape() move() resize() display() <<graphics>> 4.3.1 属性 •标准格式： –[可见性] 属性名[: 类型] [‘[’多重性[次序]‘]’][＝初始 值][{特性}] •可见性：可访问性 •多重性：属性值个数格式 •次序：属性值顺序 •特性：属性约束 166 4.3.1 属性 •可见性 –属性的可访问性，四类： •公共（public） ＋ •私有（private） － •保护（protected） # •实现（implementation） ~ /包（package） 4.3.1 操作 •标准格式： –[可见性] 操作名[（参数列表）] [：返回类型][{特性}] •例： –+ display() –# create() –－attachXWindow(xwin:XWindowPtr) –+ getname() : String 168 4.3.2 类的关系 •四类基本关系： –关联（association）","merge.pdf_47":": String 168 4.3.2 类的关系 •四类基本关系： –关联（association） –泛化（generalization） –实现（realization） –依赖（dependency） 169 4.3.2 类的关系——关联 •关联关系是类与类之间的联结，它使一个类知道另 一个类的属性和方法。 •在 Java 或 c++ 中，关联是通过使用成员变量来实 现的。 class 徒弟 { }; class 唐僧 { protected: list<徒弟> tdlist; }; 4.3.2 类的关系——关联 •关联分单向或双向 RegistrationForm RegistrationManager 1..* 0 单向关联 171 4.3.2 类的关系——关联 •关联名 student teacher teaching 172 4.3.2 类的关系——导航性 •Navigability –从一个类（对象）可以找到另外一个，反过来却不可。 idpassword 173 4.3.2 类的关系——关联角色 •Association role teacherstudent","merge.pdf_48":"4.3.2 类的关系——关联角色 •Association role teacherstudent +teach n +study nnn 174 4.3.2 类的关系——关联的多重性 •Multiplicity –0表没有实例的关联 –0..1 –0..n –1 –1..n –n –2, 4..6 –一个教师可以开设一到三门课，一门课程有一到多名教师 讲授 teachercourse 1..3 1..n1..n 1..3 4.3.2 类的关系——聚合 Student CourseOffering Professor name numberCredits major location open( ) addStudent(StudentInfo) tenureStatus Course Copy Right X.Shi, DHU176 4.3.2 类的关系——聚合 •Aggregation –聚合关系中，两个类处于不同的层次上，一个代表整体，一个代表部分。个体可以属于多个整 体； –聚合关系也是通过成员变量来实现的。 –class 引擎 { }; class 轮胎 { };","merge.pdf_49":"； –聚合关系也是通过成员变量来实现的。 –class 引擎 { }; class 轮胎 { }; class 汽车 { protected: 引擎 engine; 轮胎 tyre[4]; }; 177 4.3.2 类的关系——组合 •Composition –整体和部分的关系，个体唯一属于一个整体； –它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 class 肢 { }; class 人 { protected: 肢 limb[4]; }; 178 4.3.2 类的关系——自反关联 •Reflexive Association –主要指类的不同实例间存在关联 file folder 0..1 0..n +paren t +son 0..n 0..1 file folder 0..n 0..10..1 0..n +parent 179 4.3.2 类的关系——派生关联 •Derived Association –{ person.employer=person.department.employer }","merge.pdf_50":"n –{ person.employer=person.department.employer } –一个公司有多个部门，一个职员为其中某部门工作，则可推导该职员为该公司工作 department company 1..n1 person n 1 n 1 为部门工作 /为公 司工作 11..n 1 n n 1 180 4.3.2 类的关系——受限关联 •QualifiedAssociation –受限关联用于一对多或多对多的关联。限定符（qualifier）用来区分关联“多”端的对象集合， 它指明了在关联“多”端的某个特殊对象。 181 4.3.2 类的关系——关联约束/依赖 •Association Constraint/Dependency 182 4.3.2 类的关系——关联类 –即是关联也是类，它不仅像关联那样连接两个类，而且还可以定义一组属于关系本身的特性 score score : Single student stuID : String course courseID : String 1..10 1..n 1..10 1..n 4.3.2 类的关系——泛化","merge.pdf_51":"eID : String 1..10 1..n 1..10 1..n 4.3.2 类的关系——泛化 •Generalization –一般元素和特殊元素之间的关系。 用户 操作员 管理员 课程 必修课 选修课 4.3.2 类的关系——泛化 •继承 –子类共享父类的属性和操作 person name : string student stuID : String teacher teacherID : String 4.3.2 类的关系——泛化 •学生和教授用《学生注册管理系统》的第一步要登 陆。所以他们都有登录用户的含义 Student Professor name RegistrationUser 4.3.2 类的关系——泛化 •多态 –子类的实例用于任何父类被声明使用的地方，实现多态 –尽管每个子类的实现方法各自不同，但外界调用的方式完 全一样： Shape *oShape; Line *oLine; oLine=new line; oShape=oLine; oShape->draw(); S h a p e L i n eC i r c l eS q u a r e","merge.pdf_52":"->draw(); S h a p e L i n eC i r c l eS q u a r e R e c t a n g l e 4.3.2 类的关系——依赖关系 •依赖关系表达了概念之间的依赖性。比如类R中需要 调用类S的算法，因此表现为依赖，表示方法虚箭头 线。 RegistrationManager ScheduleAlgorithm 188 4.3.2 类的关系——实现 •一个元素完成另外一个元素的操作功能 •如接口类及其实现；接口没有属性，只有声明的操作方法（对方法没有实现部分） ，而由实现类具体定义实现部分。 接口 实现 接口 <<Interface>> 实现 4.3.3 其它——接口 接口名称 Remote Control Remote Sensor Remote Sensor Remote Control Manufacturer A Manufacturer B Manufacturer C Remote Sensor Manufacturer A Manufacturer B Manufacturer C Remote Control","merge.pdf_53":"er A Manufacturer B Manufacturer C Remote Control Remote Sensor <<interface>> 4.3.3 其它——抽象类 Student Professor name RegistrationUser 课程注册系统 4.3.2 类的关系——类图 •一张复杂的类图 4.3.2 类的关系——类图 RegistrationForm RegistrationManager Course Student CourseOffering Professor addStudent(Course, StudentInfo ) name numberCredits open ( ) addStudent(StudentInfo ) major location open ( ) addStudent (StudentInfo ) tenureStatus ScheduleAlgorithm 1 0..* 0..* 1 4.3.4 分析类 193 系统边界 用例行为协调 系统信息 <<boundary>> <<control>>","merge.pdf_54":"分析类 193 系统边界 用例行为协调 系统信息 <<boundary>> <<control>> <<entity>> 系统信息 <<entity>> 系统边界 <<boundary>> 194 4.3.5 寻找分析类 •边界类 –位于系统与外界的交界处，例如窗体、对话框、报表、与 外部设备或系统交互的类等等； –边界类可以通过用例确定，因为活动者必须通过边界类参 与用例； NewClass2 NewClass2 <<boundary>> NewClass2 4.3.5 寻找分析类 •边界类 –Register for Courses Student Course Catalog Register for Courses RegisterForCoursesForm CourseCatalogSystem 课程注册系统 4.3.5 寻找分析类 •实体类 –表示系统中的关键概念，用来保存或管理信息，通常都是 永久信息，最终可能映射数据库中的表和字段； student student <<entity>> student 4.3.5 寻找分析类 •实体类","merge.pdf_55":"udent student <<entity>> student 4.3.5 寻找分析类 •实体类 –Register for Courses (Create Schedule) Student Schedule CourseOffering 课程注册系统 4.3.5 寻找分析类 •控制类 –协调其他类工作和控制总体逻辑流程，进行事务管理、资 源协调、错误处理等。一般每个用例有一个或多个控制类。 转账 转账 <<control>> 转账 4.3.5 寻找分析类 •控制类 –Register for Courses Course Catalog System Register for Courses RegistrationController 课程注册系统 Student 4.3.5 寻找分析类 •分析类 200 Actor 1 <<boundary>> <<control>> <<boundary>> <<entity>><<entity>> Actor 2 4.3.5 寻找分析类 •对每一个用例实现 –从用例行为中发现类 –把用例行为分发给类 •对每一个（分析）类 –描述职责","merge.pdf_56":"•对每一个用例实现 –从用例行为中发现类 –把用例行为分发给类 •对每一个（分析）类 –描述职责 –描述属性和关系 •统一分析类 201 用例分析类 用例分析 4.3.5 寻找分析类 •所有分析类 Student Course Catalog System Register for Courses Use-Case Model Design Model RegisterForCoursesForm CourseCatalogSystem StudentSchedule CourseOffering RegistrationController 4.3.6 绘制分析级类图 •绘制单个用例的分析级类图 203 课程注册系统 Student CourseOffering RegistrationController CourseCatalogSystem Schedule RegisterForCoursesForm 4.3.6 绘制分析级类图 •合并多个用例的分析类 204 Register for Courses Close Registration Student Course","merge.pdf_57":"ter for Courses Close Registration Student Course Offering Course Offering Student CloseRegistration Controller Registration Controller CloseRegistration Form Course Catalog System Schedule Course Catalog System Course Offering Schedule Registration Controller Student CloseRegistration Controller Schedule Course Catalog System Billing System RegisterFor CoursesForm RegisterFor CoursesForm CloseRegistration Form Billing System 课程注册系统 谢谢 ！ 4.4 用顺序图建模用例行为 •交互图概述 –Interaction diagram，是描述对象之间的关系和对象之间","merge.pdf_58":"模用例行为 •交互图概述 –Interaction diagram，是描述对象之间的关系和对象之间 的信息传递的图； •强调对象交互的图 –顺序图（Sequence Diagram） –通信图（Communication Diagram） •专门的图 –计时图（Timing Diagram） –交互纵览图（Interaction Overview Diagram） 4.4 用顺序图建模用例行为 •Sequence Diagram –面向时间描述对象交互的视图 •Communication Diagram –对象间消息的结构化视图 Communication Diagrams Sequence Diagrams 4.4 用顺序图建模用例行为 •Timing Diagram –交互中消息有关的时间约束视图 •Interaction Overview Diagram –混合逻辑序列的高级交互视图 Interaction Overview Diagrams Timing Diagrams 4.4.1 顺序图 •按照时间顺序显示对象之间交互的图； –活动者（actor） –对象（object）","merge.pdf_59":".1 顺序图 •按照时间顺序显示对象之间交互的图； –活动者（actor） –对象（object） –生命线（lifeline） –控制焦点（ focus of control ）/激活期 –消息（message） –交互片断（Interaction Frame） 4.4.2 活动者或对象 •一般活动者和对象按照从左到右的顺序排列，主要 活动者排在最左边； 210 :RegisterForCours esForm :Registration Controller SWTSU Catalog: CourseCatal ogSystem : Student Actor instances 课程注册系统 4.4.2 活动者或对象 •对象的命名方式有三种： –包括对象名和类名 –类名（匿名对象） –对象名（不关心类） 211 uml : cour se : c ourse UML 4.4.3 生命线 •每个对象都有自己的生命线，是一条垂直的虚线，用来表示 一个对象在一段时间内存在。 •如对象生命期结束，则用注销符号表示； 212 4.4.4 控制焦点","merge.pdf_60":"一个对象在一段时间内存在。 •如对象生命期结束，则用注销符号表示； 212 4.4.4 控制焦点 •控制焦点（ focus of control ）/激活期 –对象执行某个动作的时期 213 源对象 目标对象 return:=message(para) 4.4.5 消息 •对象间交互信息的方式，消息分为五种： –对象创建、同步调用、返回、异步消息、交叉异步消息、对象销毁 214 4.4.5 消息 •UML三种消息： –同步调用（Procedure Call） •发送者把消息发送后，等待直到接收者返回控制，可以表示同步； 215 源对象目标对象 4.4.5 消息 •UML三种消息： –异步（Asynchronous） •消息发送后，发送者继续操作，不等待，常用于并发； 216 源对象 目标对象 message(para) 4.4.5 消息 •UML三种消息： –返回（Return） •表示消息的返回。一般同步（过程调用）的返回不需画出，直接 隐含，而异步返回则可用它。 217 源 对 象 目 标 对 象 m e s s a g e ( p a r a )","merge.pdf_61":"则可用它。 217 源 对 象 目 标 对 象 m e s s a g e ( p a r a ) m e s s a g e 1 ( p a r a ) 4.4.5 消息 •自调用（Self Call） –UML 标记ROSE 标记 218 4.4.6 交互片断 •Interaction Frame –UML2.0中新增，代表交互中的一个区域或者片段，并且 用一个标签来定义，用来建模特殊的交互。 •类型 seq -weak sequencing critical -critical region ignore -ignore consider -consider assert -assertion neg -negative alt -alternatives opt -option loop -iteration break -break par -parallel strict -strict sequencing 4.4.6 交互片断 •Alt(alternatives，备选) –表示多条件的分支结构（选择结构）","merge.pdf_62":".4.6 交互片断 •Alt(alternatives，备选) –表示多条件的分支结构（选择结构） –虚线分隔区域，每一个区域设置一个监护条件，代表一个 分支 220 4.4.6 交互片断 •Opt（option，可选） –表示在（唯一）操作数发生或不发生的情况下的行为选择。 –一个选项在语义上等价于一个可选的组合片段，其中有一 个操作数的内容为非空，而第二个操作数为空 221 4.4.6 交互片断 •loop（循环） –表示一个循环。 –循环操作数可以有迭代边界，该边界可以 包括循环的上下迭代次数。语法为： •循环操作数：：=循环['（'min int['，'max int]'）'] •最小整数：：=非负整数 •最大整数：：=正整数|'*’ •如果循环没有指定界限，则意味着潜在的无限 循环，下界为零，上界为无限。 222 4.4.6 交互片断 •Break（中断） 表示执行的中断或异常场景，而不是封闭交互片段的其余 部分。如果监护条件为“真”则执行子片断，而且不执行 包含子片断图中其它交互；如果监护条件为“假”，那么 执行将正常地继续进行。 223 4.4.6 交互片断","merge.pdf_63":"片断图中其它交互；如果监护条件为“假”，那么 执行将正常地继续进行。 223 4.4.6 交互片断 •Par（parallel，并行） –用来表示潜在的并行执行，即表示两个或多个并发执行的 子片断，并行子片断中单个元素的执行次序可以以任何可 能的顺序相互操作。 –例：搜索Google，Bing并按任何顺序询问，可能是并行 的。 224 4.4.6 交互片断 •Strict （strict sequencing，严排序） –要求对组合片段中的第一级操作（交互）进行严格的排序 （顺序）。 –例：先搜索谷歌，然后必应，最后雅虎 4.4.6 交互片断 •Seq （weak sequencing，弱排序） –表示交互行为之间的弱排序。 –每个操作数中出现规范的顺序都保持不变，即当操作数在 同一参与者上工作时，弱排序相当于为严格排序。 –来自不同操作数的不同生命线上的出现规范可以按任何顺 序出现，即当操作数位于不同的参与者集上时，弱排序相 当于并行。 例：谷歌搜索与必应或雅虎 可能没有先后顺序，但必应 一定在雅虎前面。 4.4.6 交互片断 •Critical","merge.pdf_64":"与必应或雅虎 可能没有先后顺序，但必应 一定在雅虎前面。 4.4.6 交互片断 •Critical –表示该子片断是“临界区域”，在临界区域中生命线上的 事件序列不能够和其它区域中的任何其他事件交错。通常 用来表示一个原子性的连续操作，例如事务性操作 227 4.4.6 交互片断 •Ignore –定义了交互片段不应该响应（应被忽略）的消息，即：有 些消息类型没有显示在这个组合的片段中，或者是可能会 出现，如果出现，则应该忽略掉； –可以用来指定对现有系统的测试。忽略的消息列表紧跟在 一对大括号“{”和“}”中包含的操作数之后。Ignore操 作通常assert一起使用，如： •“assert Ignore{m，s}” 4.4.6 交互片断 •consider –表示只允许出现列表中的消息，忽略任何其他消息。相当 于有些消息会出现，如果出现了就应该被考虑。 –所考虑的消息列表紧跟在一对大括号“{”和“}”中的操 作数之后。通常与assert组合使用，如： •assert consider{m，s} 229 4.4.6 交互片断 •Assert（assertion，确定）","merge.pdf_65":"onsider{m，s} 229 4.4.6 交互片断 •Assert（assertion，确定） –用来表示内容所描述的行为是执行过程中那个时刻唯一的 有效行为。如果执行到这个片断的前面，则说明该片断就 一定会发生。它通常和ignore或consider一起使用。 230 例：此时只能出现 Commit （）消息， 结束后任务应该是完成状态 4.4.6 交互片断 •Neg –用来标志不应该发生的交互，即此时这些消息不可用（交 互不应该发生）； –定义了无效或者错误的交互片段，通常是系统发生故障时 出现的交互片段。 4.4.6 交互片断 •Ref –表示交互被定义在另一个图中。 –在一个交互图中，我们可以引用其它的交互图，其表示的 方法是用一个矩形，加上ref操作符，并写明引用的交互图 名称即可。 –可将一个规模较大的图划分为若干个规模较小的图，方便 图的管理和复用。 232 4.4.7 门 •Gate –门是一个消息端 连接点，用于将 交互片段外部的 消息与交互片段 内部的消息相关 联。 –门和门之间消息 的目的是为每一 条消息指定具体 的发送者和接收 者。 4.4.8 时间约束","merge.pdf_66":"联。 –门和门之间消息 的目的是为每一 条消息指定具体 的发送者和接收 者。 4.4.8 时间约束 234 4.4.9 状态恒量 •state invariant –是表示交互参与者的运行时约束的交互片段。它可以用于 指定不同类型的约束，例如属性或变量的值、内部或外部 状态等。 –通常显示为生命线上大括号中的约束或状态符号，表示与 检查生命线所表示的对象状态的约束等价的状态。 –例：激活期结束时任务应该是完成状态。 235 236 附 Rose 中消息 源对象 目标对象 1: 2: 3: 4: 5: 6: 7: 237 附 Rose 中消息 •其中： –Simple和Asynchronous同义； –Synchronous和Procedure Call同义 •Return 不变 •新增： –阻止（Balking） •接收者如果无法立即接收， 则发送者放弃消息； –超时（Time-out） •如果接收者无法在指定时间 内接收，则发送者放弃消息； 源对象 目标对象 1: 2: 3: 4: 5: 6: 7: 4.4.10 建立顺序图步骤 •确定交互的范围； •识别参与交互的对象和活动者；","merge.pdf_67":"5: 6: 7: 4.4.10 建立顺序图步骤 •确定交互的范围； •识别参与交互的对象和活动者； •设置对象生命线的开始和结束； •设置消息； •细化消息； 238 4.4.11 建模用例行为 •注册课程 •基本流程 239 课程注册系统 : Student : Student : RegisterForCourse... : RegisterForCourse... : RegistrationCont... : RegistrationCont... 1: // register for courses( ) 2: // is registration open?( ) 3: // display possible operations( ) [ registration o... 4: // create schedule( ) Sequence Diagram: Register for Courses / Register for Courses - Basic Flow (Cre... 5: // update schedule( ) Sequence Diagram:","merge.pdf_68":"Cre... 5: // update schedule( ) Sequence Diagram: Register for Courses / Register for Courses - Basic Flow (Update Schedule) 6: // delete schedule( ) Sequence Diagram: Register for Courses / Register for Courses - Basic Flow (Del... One of these is executed: 4.4.11 建模用例行为 •注册课程（创建课表） 240 : Student : RegisterForCoursesForm : RegistrationController: Course Catalog : CourseCatalogSystem 1: // create schedule( ) 5: // display course offerings( ) 2: // get course offerings( )","merge.pdf_69":"course offerings( ) 2: // get course offerings( ) 3: // get course offerings(forSemester) 6: // display blank schedule( ) 4: // get course offerings( ) Select Offerings Submit Schedule ref ref 课程注册系统 4.4.11 建模用例行为 •注册课程 （提交课表） : CourseOffering : CourseOffering : Student : Student : RegisterForCoursesForm : RegisterForCoursesForm : RegistrationController : RegistrationController : Schedule : Schedule : Student : Student : PrimaryScheduleOfferingInfob : PrimaryScheduleOfferingInfob","merge.pdf_70":"eduleOfferingInfob : PrimaryScheduleOfferingInfob Repeat for all primary course offerings. An attempt is made to register the student for all selected course offerings 1: // submit schedule( ) 2: // submit schedule( ) 4: // submit( ) 7: // still open?( ) 9: // add student(Schedule) 6: // has pre-requisites(CourseOffering) 8: // any conflicts?( ) 5: // is selected?( ) 10: // mark as enrolled in( ) 3: // save( ) Sequence Diagram: Register for Courses / Register for Courses - Save Schedule","merge.pdf_71":"or Courses / Register for Courses - Save Schedule [ has pre-requisites, course offering open, and no schedule conflicts ] [ is selected ] 课程注册系统 4.4.11 建模用例行为 •不当的使用——建模业务流程 广州点 虎门中转点 深圳中转点 收件办事处 广东省发件办事处 {13：30}虎门中转 带回各区至本区件 {22：30}广州中转 {03：00}深圳中转 带回各区至本区件 带回各区至本区件 练习 1、用户打印文件，计算机向打印服务器发送打印命令， 打印机如果空闲，则直接打印，否则把打印文件存 储在打印队列中。 练习 : 用户 : 计算机 : 打印服务器 : 打印机 : 队列 print(file)print(file) [if free]print(file) [if busy]Store(file) 练习 2、管理员通过课程管理器打印课程UML的信息； 练习 3、管理员通过课程管理器打印所有课程信息 : 管理员 : 课程管理器 : course","merge.pdf_72":"息； 练习 3、管理员通过课程管理器打印所有课程信息 : 管理员 : 课程管理器 : course printcourse() printinfo() *:printcourse( ) 4.5 用通信图建模用例行为 •描述系统对象（或活动者）如何共同协作实现用例； 247 课程注册系统 4.5.1 通信图组成 248 4.5.1 通信图组成 •链： –连接器，是用来表示对象之间的语义连接，一般而言，链 是关联的一个实例（包括《association》、《self》、 《global》、《local》等）。不过在UML 2中已经开始弱 化它们的使用，因此除非必要，无需过多地考虑它们 •消息编号： –消息的编号有两种，一种是无层次编号，它简单直观；另 一种是嵌套的编号，它更易于表示消息的包含关系 •迭代标记： –用*号表示，表示循环，通常还有迭代表达式，用来说明循 环规则 249 4.5.1 通信图组成 •监护条件： –通常是用来表示分支的，也就是表示“如果条件为true， 才发送消息” 250 课程注册系统 4.5.1 通信图组成 •多重对象 –多个对象的集合，往往是同类的对象；","merge.pdf_73":"” 250 课程注册系统 4.5.1 通信图组成 •多重对象 –多个对象的集合，往往是同类的对象； –如果消息同时发给多个对象，则用多重对象表示； –在顺序图中仍然显示为单对象一样的图标； 251 课程 课程 4.5.1 通信图组成 •活动对象 –拥有控制线程的对象，能够发起控制活动； –某种意义下，代表线程； Uml 符号Rose 符号 252 : robot ac tive 4.5.2 建模用例行为 253 : Student : RegisterForCoursesForm : RegistrationController : CourseCatalogSystem 5: // display course offerings( ) 6: // display blank schedule( ) 1: // create schedule( ) 2: // get course offerings( ) 3: // get course offerings(forSemester) 4: // get course offerings( ) : Course Catalog","merge.pdf_74":"r) 4: // get course offerings( ) : Course Catalog 课程注册系统 练习 1、用户打印文件，计算机向打印服务器发送打印命令， 打印机如果空闲，则直接打印，否则把打印文件存 储在打印队列中。 254 练习 : 用户 : 计算机 : 打印服 务器 : 打印机 : 队列 1: print(file)2: print(file) 7: 3: [if free]print(file) 4: 5: [if busy]Store(file) 6: 255 练习 •练习2、管理员通过课程管理器打印所有课程信息 : 管理员 1 : 课程 管理器 : course 2: *:printcourse( ) 4: 1: printcourse() 3: printinfo() 256 257 4.6 用交互纵览图细化活动细节 •交互纵览图是将活动图和顺序图嫁接在一起的图 •可以看作活动图的变体，它将活动节点进行细化， 用一些小的顺序图来表示活动节点内部的对象控制 流 •交互纵览图在草图中更加适用，先通过活动图对业 务流程进行建模，然后对于一些关键的、复杂度并","merge.pdf_75":"流 •交互纵览图在草图中更加适用，先通过活动图对业 务流程进行建模，然后对于一些关键的、复杂度并 不高的活动节点进行细化，用顺序图来表示它的对 象间的控制流 258 4.6 用交互纵览图细化活动细节 259 1）理清主线—用活动图表述主线 Copy Right X.Shi,DHU260 2）用顺序图描述细节 260 补充： 用计时图建模时间约束 •Timing Diagram –交互图之一，建模在生命线内或生命线之间沿一条线性时 间轴的状态或条件变化。 –主要目的是展示一个生命线（代表一个对象或活动者）的 状态或条件随线性时间的改变。最常见的用法是展示一个 对象随着时间对接受的事件或刺激响应下的状态变化。 261 补充： 用计时图建模时间约束 262 计时图组成 •生命线 –同顺序图一样，生命线是一个命名元素，代表交互中的单 个对象或者活动者，可以放在分区（或者泳道）内。 –改为从左到右来表示时间的推移。 263 计时图组成 •状态或者条件时间线 –可以显示参与的对象（或者活动者）的状态、属性或者一 些可测试的条件，例如属性的离散值或可枚举值。 264 计时图组成 •消息 265","merge.pdf_76":"状态、属性或者一 些可测试的条件，例如属性的离散值或可枚举值。 264 计时图组成 •消息 265 计时图组成 •持续时间约束（Duration Constraint） –是指持续时间间隔的间隔约束，用于确定是否满足约束的 持续时间。 –建模状态或条件等持续的时间。 266 计时图组成 •时间约束（Time Constraint） –是指时间间隔的间隔约束，用于确定是否满足约束的时间 表达式 –时间约束表现为时间间隔与其约束的结构之间的图形关联 。通常，这种图形关联是一条小线，例如，在发生规范和 时间间隔之间。 –例：人应该在5:40 am 至 6 am 之间醒来 计时图组成 •销毁事件 –是一个消息事件，表示生命线所描述的对象的销毁。它可 能导致该对象通过组合拥有的其他对象的后续销毁。在给 定生命线上发生破坏事件后，不得出现其他事件。 268 269 计时图组成 •时间刻度 –可显示一个度量时间值的标尺，用刻度表示时间间隔 269 计时图 270 计时图 271 补充： 交互模型的类型与演变 272 4.7 丰富类图 •4.7.1 描述职责 –由交互图中消息确定类的职责 273","merge.pdf_77":"类型与演变 272 4.7 丰富类图 •4.7.1 描述职责 –由交互图中消息确定类的职责 273 // PerformResponsibility :Client:Supplier Supplier // PerformResponsibility Interaction Diagram Class Diagram 4.7.1 描述职责 •把消息映射为分析类的操作 274 RegistrationController // get course offerings() <<control>> CourseCatalogSystem // get course offerings() <<boundary>> RegisterForCoursesForm // display course offerings() // display blank schedule() // create schedule() <<boundary>> 课程注册系统 4.7.2 描述属性 •根据交互图关系等确定分析类的属性 •分析类中，属性类型仅仅考虑业务领域的类型，不 要考虑编程语言","merge.pdf_78":"•根据交互图关系等确定分析类的属性 •分析类中，属性类型仅仅考虑业务领域的类型，不 要考虑编程语言 ClassName <<stereotype>> Attribute : Type = InitValue Attribute : Type = InitValue Attribute : Type = InitValue 属性 CourseOffering number : String = \"100\" startTime : Time endTime : Time days : Enum numStudents : Int <<entity>> 4.7.3 描述关系 276 PerformResponsibility 连接 关系 类图 0.. * 0.. * Client Supplier :Client:Supplier Client Supplier PerformResponsibility() 通信图 4.7.3 描述关系 •聚合 277 整体 部分 0..20..* CourseOffering <<entity>> Schedule <<entity>> Student","merge.pdf_79":"seOffering <<entity>> Schedule <<entity>> Student <<entity>> 1 0..* 1 课程注册系统 4.7.3 描述关系 •角色 Role Name CourseOffering <<entity>> Professor <<entity>> Instructor Department <<entity>> Department Head Course <<entity>> Prerequisites 课程注册系统 4.7.3 描述关系 •多重性 279 Course <<entity>> Prerequisites 0..3 0..* CourseOffering <<entity>> 0..*1 课程注册系统 4.7.3 描述关系 •关系名不能用动词 CourseOffering <<entity>> Schedule <<entity>> primaryCourses alternateCourses CourseOffering <<entity>> Schedule <<entity>> add student to","merge.pdf_80":"ing <<entity>> Schedule <<entity>> add student to remove student from 课程注册系统 4.7.3 描述关系 •关联类 Schedule <<entity>> CourseOffering <<entity>> 0..n0..40..n +primaryCourses 0..4 0..n 0..2 0..n +alternateCourses 0..2 PrimaryScheduleOfferingInfob grade // is enrolled in?() // mark as enrolled in() // mark as committed() <<entity>> ScheduleOfferingInfo status // mark as selected() // mark as cancelled() // is selected?() <<entity>> 课程注册系统 FulltimeStudent <<entity>> ParttimeStudent <<entity>>","merge.pdf_81":"timeStudent <<entity>> ParttimeStudent <<entity>> PrimaryScheduleOfferingInfo <<entity>> ScheduleOfferingInfo <<entity>> Student <<entity>> 4.7.3 描述关系 •泛化 4.7.4 丰富类图 •丰富类图 283 课程注册系统 PrimaryScheduleOfferingInfob grade // is enrolled in?() // mark as enrolled in() // mark as committed() <<entity>> ScheduleOfferingInfo status // mark as selected() // mark as cancelled() // is selected?() <<entity>> CourseOffering number : String = \"100\" startTime : Time endTime : Time days : Enum","merge.pdf_82":"\"100\" startTime : Time endTime : Time days : Enum / numStudents : Int // add student() // remove student() // close registration() // get number of students()... // cancel() // still open?() // add professor() // close() // save() <<entity>> RegisterForCoursesForm // submit schedule() // display course offerings() // update schedule() // delete schedule() // confirm schedule deletion() // request schedule delete confirmation() // display schedule(theSchedule : Schedule)...","merge.pdf_83":"() // display schedule(theSchedule : Schedule)... // register for courses() // display possible operations() // save schedule() // create schedule() // select 4 primary and 2 alternate offerings()... // display blank schedule() // update offering selections() <<boundary>> Student name address studentID // get tuition() // add schedule(theSchedule : Schedule) // get schedule(forSemester) : Schedule // delete schedule(forSemester)","merge.pdf_84":"ester) : Schedule // delete schedule(forSemester) // has pre-requisites(forCourseOffering : CourseOffering) : boolean... <<entity>> Schedule semester // commit(theOffering : CourseOffering) // select alternate() : CourseOffering // remove offering(theOffering : CourseOffering)... // level() // cancel(theOffering : CourseOffering) // get cost() // delete() // submit() // save() // any conflicts?() // create with offerings() // update with new selections() <<entity>> 0..n 1 0..n 1 0..n 0..4 0..n","merge.pdf_85":"ections() <<entity>> 0..n 1 0..n 1 0..n 0..4 0..n +primaryCourses 0..4 0..n 0..2 0..n +alternateCourses 0..2 RegistrationController // get course offerings() // get current schedule(forStudent : Student, forSemester)... // delete current schedule() // submit schedule() // is registration open?() // save schedule() // create schedule with offerings() // update schedule with new selections() <<control>> 1 1 1 1 0..1 0..1 0..1 +registrant 0..1 0..1 0..1 0..1 +currentSchedule 0..1 Course Catalog","merge.pdf_86":".1 0..1 0..1 +currentSchedule 0..1 Course Catalog (from Use Case View) CourseCatalogSystem // get course offerings(forSemester)... <<boundary>> 0..n 1 0..n 1 0..1 0..1 0..1 0..1 4.7.5 设计原则 •单一职责原则（Single Responsibility Principle） •开闭原则（Open Closed Principle） •里氏替换原则（Liskov Substitution Principle） •依赖倒置原则（Dependence Inversion Principle） •接口分离原则（Interface Segregation Principle） •迪米特法则（Law of Demeter） •参考 ： –http://www.cnblogs.com/LangZXG/p/6242925.html","merge.pdf_87":"： –http://www.cnblogs.com/LangZXG/p/6242925.html –https://www.cnblogs.com/LangZXG/p/6242927.html 1）、单一职责原则 •应该有且只有一个原因引起类的改变，即一个类只 负责一个职责。 –比如让类C负责两个不同的职责：职责P1，P2。当由于职责P1需求发 生改变而需要修改类C时，有可能会导致原本运行正常的职责P2功能 发生故障。类的职责越少，则对象之间的依赖关系就越少，耦合度就 越低。 2)、开闭原则 •指一个对象（类，模块，函数等等）在扩展性方面 是开放的，在更改性方面是封闭的。 •可以通过“抽象约束、封装变化”来实现开闭原则， 即通过接口或者抽象类为软件实体定义一个相对稳 定的抽象层，而将相同的可变因素封装在相同的具 体实现类中。 2)、开闭原则 •开闭原则 –左：oupput逻辑复杂，修改复杂 –右 ：添加具有print方法的接口。 output hp print() epson print() lenov print() printer print() output hp","merge.pdf_88":"n print() lenov print() printer print() output hp print() epson print() lenov print() <<uses>> <<uses>> <<uses>> 2)、开闭原则 •书店刚开始卖小说类书籍，后来要求小说类书籍打折处理（ 40元以上9折，其他8折），再后来书店增卖计算机类书籍（ 比小说类书籍多一个属性“类别”）。后来要求小说类书籍 打折处理（40元以上9折，其他8折） 3)、里氏替换原则 •只要父类出现的地方子类就可以出现，而且将其替 换为子类也不会产生任何出错或者异常。 •子类必须完全实现父类的方法（方法不能为空）。 即父类的方法必须是子类全部需要的，如果不是全 部需要的，就违背了LSP原则。 •在类中调用其他类时必须使用父类或者接口，如果 不使用父类或者接口，则类的设计违背了LSP原则。 3)、里氏替换原则 •例 ： –某公司有普通用户和vip用户，他们发邮件的过程如下左 ，分析发现普通用户和vip用户发邮件的过程是相同的，即 两个send()方法重复。将来还可能增加用户新类型，为了","merge.pdf_89":"用户和vip用户发邮件的过程是相同的，即 两个send()方法重复。将来还可能增加用户新类型，为了 让系统具有更好的扩展性，使用里氏替换原则进行重构。 4)、依赖倒置原则 •实现类之间不发生直接的依赖关系，其依赖关系是 通过接口或者抽象类产生的。即面向接口编程。 •实现类依赖接口或者抽象类，而接口或者抽象类不 依赖于实现类。 司机开奔驰车 司机不仅要开奔驰，要开宝马车 5)、接口分离原则 •设计时采用多个与特定客户类有关的接口比采用一 个通用的接口好。 a b c service a() b() c() <<Interface>> imp a b c serviceA a() serviceB b() serviceC c() imp 6）、迪米特法则 •一个对象应该对其他对象有最少的理解，即一个类 应该对自己，一个类只能和朋友类交流需要耦合或 需要调用的类知道的最少。 •例 ：老师让班长清点全班人数 4.8 描述分析机制 分析类分析机制 Student Schedule CourseOffering Course RegistrationController","merge.pdf_90":"dule CourseOffering Course RegistrationController Persistency, Security Persistency, Legacy Interface Persistency, Legacy Interface Distribution Persistency, Security 谢谢 ！ UML建模技术 第5章 系统设计（用例设计） UML建模技术石秀金 297 5.1 OOD •从OOA到OOD 298 Supplementary Specification Use-Case Model Design Model Data Model Architecture Document Analysis and Design Glossary 5.1 OOD •步骤 –定义设计类 –用状态机图建模系统行为 –用构件图建模系统组成 –建模数据库 –用包图管理系统元素 –描述运行期架构 –标识设计机制 –用部署图建模系统安装 –用子系统简化顺序图 –类的设计 5.2 定义设计类 300 Design Classes Subsystems","merge.pdf_91":"顺序图 –类的设计 5.2 定义设计类 300 Design Classes Subsystems Analysis Classes 5.2.1分析类映射设计类 •下列情况分析类直接映射为设计类: –简单的类 –单独的逻辑抽象 •更多分析类： –拆分为多个类 –成为一个包 –成为子系统 –混合的 ... 301 5.2.1分析类映射设计类 •重新定义操作 RegisterForCoursesForm // display course offerings() // display blank schedule() // create schedule() <<boundary>> RegisterForCoursesForm getCourseOfferings() geBlankSchedule() newSchedule() 302 5.2.2 定义类的关系 •关联关系 303 课程注册系统 5.2.2 定义类的关系 •泛化关系 304 FulltimeStudent ParttimeStudent PrimaryScheduleOfferingInfo","merge.pdf_92":"udent ParttimeStudent PrimaryScheduleOfferingInfo ScheduleOfferingInfo Student 课程注册系统 5.3 用状态机图建模系统行为 •状态机 –用于描述一个对象在其生存期间的动态行为，表现对象响应事件所经 历的状态序列以及伴随的动作。 •状态机图（State Machine Diagram） –用来显示状态机，一个状态机可用多张状态图描述。 305 5.3.1 基本组成 •状态 •转换 •事件 306 课程注册系统 5.3.1 基本组成 307 5.3.2 状态 •什么是状态（state） –对象生命期中的某个条件或状况，在此期间对象将满足某 些条件、执行某些活动或等待某些事件。 •理解 –对象在任何时候都会处于某种状态中，所有对象都有状态。 –对象所处的状态决定了它如何响应所检测到的事件或所接 收的消息。 –通常，事件使对象从一个状态转向另一个状态（即状态的 转移） 308 5.3.2 状态 •几种类型： –初态 –终态 –中间状态 –组合状态 –历史状态 309 1）、初态和终态","merge.pdf_93":"状态 •几种类型： –初态 –终态 –中间状态 –组合状态 –历史状态 309 1）、初态和终态 •初态（start state） –显示状态图中状态机的执行（execution）的开始。 –一个状态机只能有一个初态，因为每一个执行都是从相同 的地方开始的。如果一个状态机用多张图描述，则多张图 用同一个初态； –嵌套状态中可以使用新的初态； •终态（End State） –表示一个最后的或者终端状态； –终态的数目可以不确定。 310 NewState2 NewState3 NewState4 NewState3 NewState4 NewState 2）、一般状态 •中间状态的组成： –状态名（name） –进入/退出动作（entry/exit action） –内部转换（internal transition） •不导致状态改变的转换，不会执行entry 和exit 动作。 –子状态（substate） •嵌套在另外一个状态中的状态。 –延迟事件（deferred event） •延迟到下一状态中处理的事件。 311 lighting entry/ turnO n","merge.pdf_94":"vent） •延迟到下一状态中处理的事件。 311 lighting entry/ turnO n do/ blankFiv eTimes event power off/ powerSupplySelf exit/ turnOf f event self/ defer 2）、一般状态 •延迟事件 –是一种特殊的事件，它是指该事件不会触发状态的转换， 当对象处于该状态时事件不会丢失，但会被延迟执行。 –例如，当E-mail程序中正在发送第一封邮件时，用户下达 发送第二封邮件执令就会被延迟，但第一封邮件发送完成 后，这封邮件就会被发送。这种事件就属于延迟事件 312 3）、复合状态 Test entry/ showScreen exit/ hideScreen A B A B Dialing entry/ offHook 分解指 示符 嵌套区域表示法 分解指示符法 313 •含有子状态的状态被称为复合状态。 •两种表示方法： 3）、复合状态 •顺序复合状态图（表示方法1） 314 3）、复合状态 •顺序复合状态图（表示方法2） 315 3）、复合状态 •并发复合状态图 316","merge.pdf_95":"3）、复合状态 •顺序复合状态图（表示方法2） 315 3）、复合状态 •并发复合状态图 316 4）、子状态机 •将子状态机单独定义，并对其进行命名（通常以大 写字母开头），然后在需要使用的地方来引用它 317 4）、子状态机 •例： 318 5）、历史状态 •History state –一种伪状态。可以存储退出组合状态时所处的子状态，则 返回组合状态时可以直接回到到相应的子状态。 –历史状态只能被定义在组合状态上，并且一个区域中最多 只能有一个这样的伪状态。 •两类 –shallowHistory 浅历史状态 –deepHistory深历史状态 319 5）、历史状态 •shallowHistory 浅历史状态 –返回到所属区域中最近的活跃子状态配置（组合状态的某 个子状态）； –需要执行所有进入这个子状态的语义。 320 5）、历史状态 •deepHistory 深历史状态 –返回到所属区域中最近活跃状态配置（意味着子状态的子 状态）； –进入状态的所有语义都要执行，在所复原的状态配置中所 有状态的入口行为都要按顺序执行，最外层的先执行。 321 6）、入口点和出口点","merge.pdf_96":"复原的状态配置中所 有状态的入口行为都要按顺序执行，最外层的先执行。 321 6）、入口点和出口点 •入口点 –状态内的一个外部可见的伪状态，外部转换可以将它作为 目标，从而被有效连接到指定状态上。 •出口点 –状态内的一个外部可见的伪状态，外部转换可以将它作为 源，代表状态内的一个终点。 322 5.3.3 转换 •Transition –两个状态之间的一种关系，表示对象在第一个状态中执行 一定的动作，并在某个特定事件发生而且满足某个条件时 进入第二个状态。每个转换只允许一个事件，一个事件只 允许一个动作 •转换的五要素 –源状态 –目标状态 –触发事件 –监护条件 –动作 323 1）、复杂转换 转换类型描述语法 外部转换对事件做出响应，引起状态变化或自身转 换，同时引发一个特定动作，如果离开或进 入状态将引发进入转换、离开转换 事件 ( 参数 )[ 监护条件 ]/ 活 动 内部转换对事件做出响应，并执行一个特定的活动， 但并不引起状态变化或进入转换、离开转换 事件 ( 参数 )[ 监护条件 ]/ 活 动 进入转换当进入某一状态时，执行相应活动 entry/ 活动","merge.pdf_97":"( 参数 )[ 监护条件 ]/ 活 动 进入转换当进入某一状态时，执行相应活动 entry/ 活动 退出转换当离开某一状态时，执行相应活动 exit/ 活动 324 2）、各种转换的区别 •进入和退出转换： –当进入一个状态时，执行某个动作；或当退出某个状态时， 执行什么动作。这时就可以使用进入和退出转换来表示 •内部转换： –用来处理一些不离开该状态的事件 325 3）、带有复杂转换的状态图 326 5.3.4 事件 •Event –是对一个时间和空间上占有一定位置的有意义的事情的规 格说明。 –事件触发状态的转移 •四类主要事件 –信号事件 –调用事件 –变化事件 –时间事件 327 1）、信号事件 •信号（signer）事件 –所谓信号，是指由一个对象异步地发送、并由另外一个对 象接收的一个已命名的对象。 –信号事件表示对象接收到某个信号。 –信号可以作为状态机中一个状态转换的动作而被发送，也 可作为交互中一个的消息发送。 328 hardwareFault <<signal>> RobotFault <<signal>> 1）、信号事件 329 2）、调用和变化事件","merge.pdf_98":"al>> RobotFault <<signal>> 1）、信号事件 329 2）、调用和变化事件 •调用（call）事件 –表示一个操作的调度。请求调用另一个对象的操作。 –一般是同步调用。 •变化（change）事件 –用关键字When，后面跟布尔表达式。 –When(temperature > 120) / alerm() 330 3）、时间事件 •时间（time）事件 –满足某一时间表达式的情况的出现，例如到达某一时间或 经过了某一时间段。用关键字After或When表示。 331 空闲 活动 after( 2 seconds ) / dro pConnection when( 11:35 ) / selfTest 332 5.3.5 绘制状态机图 •步骤： –寻找主要的状态 –确定状态之间的转换 –细化状态内的活动与转换 –用复合状态来展开细节 5.3.5 绘制状态机图 源目标无预订部分预订预订完预订关闭 无预订预订 () 不直接转换关闭 () 部分预订退订 (), 使预订人 =0 预订 (), 无空座关闭 () 预订完不直接转换退订 () 关闭 ()","merge.pdf_99":"订 (), 使预订人 =0 预订 (), 无空座关闭 () 预订完不直接转换退订 () 关闭 () 预订关闭无转换无转换无转换 333 5.3.5 绘制状态机图 •细化状态内的活动与转换 334 5.3.5 绘制状态机图 •使用复合状态 335 336 5.3.6 状态机图应用 •用途 –对对象生命周期建模： •主要描述对象能够响应的事件、对这些事件的响以及过去对当前 行为的影响 –对反应型对象建模： •这个对象可能处于的稳定状态、从一个状态到另一个状态之间的 转换所需的触发事件，以及每个状态改变时发生的动作 –状态机图既可以用来表示一个业务领域的知识，也可以用 来描述设计阶段对象的状态变迁 337 5.3.6 状态机图应用 •订单处理系统 取消 收到货物[ 齐全 ] 检查 do/ 检查商品 [ 未检查完 ] / 取下一个 办理发货 do/ 启动发货 [ 检查完，商品齐全 ] 等待 [ 检查完，缺部分商品 ] 收到商品[ 部分缺 ] 取消订单 取消 取消 已发货 发货 338 5.3.6 状态机图应用 •复合(rose) 取消订单 已发货 订单处理 办理发货 do/ 启动发货 检查","merge.pdf_100":"6 状态机图应用 •复合(rose) 取消订单 已发货 订单处理 办理发货 do/ 启动发货 检查 do/ 检查商品 等待 办理发货 do/ 启动发货 发货 检查 do/ 检查商品 [ 未检查完 ] / 取 下一个 [ 检查完，商品齐全 ] 等待 [ 检查完，缺部分商品 ] 收到商品[ 部分缺 ] 收 到货物[ 齐全 ] 取消 Copy Right X.Shi,DHU339 5.3.6 状态机图应用 •复杂图 （售票机） 5.3.6 绘制状态机图 addStudent / numStudents = numStudents + 1 Unassigned Assigned Full Canceled do/ Send cancellation notices Committed do/ Generate class roster closeRegistration [ has Professor assigned ] close / numStudents = 0 addProfessor closeRegistration removeStudent [numStudents >0]/","merge.pdf_101":"closeRegistration removeStudent [numStudents >0]/ numStudents = numStudents - 1 cancel removeProfessor [ numStudents = 10 ] close[ numStudents < 3 ] closeRegistration[ numStudents >= 3 ] close[ numStudents >= 3 ] addStudent / numStudents = numStudents + 1 cancel removeStudent[ numStudents > 0] / numStudents = numStudents - 1 close [ numStudents = 10 ] cancel 课程注册系统 341 5.3.7 总结 •状态机图与交互图的区别： –交互图不显示对象所有可能的动态行为，只显示特定交互 （一个具体的用例）中对象的行为。 –状态机图可以显示对象所有的动态行为。 •状态图机与活动图的区别： –状态机图只建模一个对象的行为，活动图可以建模多个对","merge.pdf_102":"所有的动态行为。 •状态图机与活动图的区别： –状态机图只建模一个对象的行为，活动图可以建模多个对 象的活动 –活动图中也允许建模特定活动中对象的某个状态 5.4 用构件图建模系统组成 5.4.1 构件 •Component） –系统中遵从并实现一组接口的物理的、可替换的软件模块 。 –组件是物理视图的基本元素。 •1.X表示法 •2.0表示法 Planner 5.4.1 构件 •可选区 5.4.1 构件 •展示构件的实现类 5.4.2 构件的类型 •一个系统往往由几个不同类型的软件模块组成，每 一个软件模块可以表示为一个组件。 •类型 –部署构件 •如dll文件、exe文件、com+对象、corba对象、ejb、动态web页、 数据库表等； –工作产品构件 •如源代码文件、数据文件等，用来产生部署构件； –执行构件 •是指系统执行后产生的构件； 5.4.2 构件的类型 •RSM/RSA 5.4.3 构件间的关系 •依赖关系 –一个构件如果使用另外一个构件的操作，则也可以在该构 件和另外一个构件的接口间建立依赖关系； 5.4.3 构件间的关系 •依赖关系 –对象和源码间","merge.pdf_103":"该构 件和另外一个构件的接口间建立依赖关系； 5.4.3 构件间的关系 •依赖关系 –对象和源码间 5.4.3 构件间的关系 •依赖关系 –两个构件中的类如果存在泛化关系，则构件间可以加依赖 关系； 5.4.3 构件间的关系 •依赖关系 –两个构件中的类如果存在使用关系，则构件间可以加依赖 关系； 5.4.3 构件间的关系 •实现关系 5.4.4 构件图 •Component diagram –提供当前模型的物理视图； –显示包括构件源码、二进制文件和可执行文件在内的软件 构件之间的组织和依赖关系； –也可以通过显示组件的接口来展示组件外部可见的行为。 5.4.4 构件图 •基本构件图 Course Course Offering Student Professor Course.dll People.dll Course User Register.exe Billing.exe Billing System 课程注册系统 5.4.4 构件图 •基本构件图 5.4.4 构件图 •嵌套构件图 5.4.5 构件图的应用 •对可执行程序的结构建模 –首先识别你想建模的构件集合","merge.pdf_104":"图 •嵌套构件图 5.4.5 构件图的应用 •对可执行程序的结构建模 –首先识别你想建模的构件集合 –考虑集合中各构件的不同类型 –对这个集合中的每个构件，分析它们之的关系 5.4.5 构件图的应用 •对源代码建模 –识别相关源代码文件的集合，建模为构件； –对于较大的系统，利用包来进行分组； –通过约束来表示源代码的 版本号、作者和最后修改 日期等信息； –用依赖关系来表示这些 文件间编译的依赖关系 5.5 建模数据库 补充规约 数据库设计 用例实现 项目规范指南 分析类设计类 设计模型 数据模型 5.5.1 设计数据库 •把持久性类映射成数据模型 •分发类的行为到数据库 360 5.5.1 设计数据库 •对象模型 –Classes (attributes) –Associations 361 LineItem - quantity : Integer - number : Integer 1..* +lineItems Order - number : Integer +order Product - number : Integer - description : String","merge.pdf_105":"Product - number : Integer - description : String - unitPrice : Double 1 Software Product - version : Double Hardware Product - assembly : String 362 Student - name : String - address : String - studentID : Long 5.5.1 设计数据库 •将持久类映射为表 –每一行为一个对象 –每一列相当于类的持久属性 NameAddressStudent_ID Thomas Stuart987 High St.123456 对象实例 对象属性 课程注册系统 363 5.5.1 设计数据库 •将两个持久对象间的关联映射为关联对象的外 键 Number Course_ID 678456789 NameDescription Number Math 101Algebra456789 Course Offering table Course table Course - name","merge.pdf_106":"Course Offering table Course table Course - name - description - number CourseOffering - number : String 0..* 1 主键 课程注册系统 外键 364 5.5.1 设计数据库 •聚合关系也用外键映射 Student. - studentID : int Schedule - semester : Semester 0..* 1 Student_IDSemester 123456Spring 2001 Schedule table Student_ID 123456 外键 主键 Student table 课程注册系统 365 5.5.1 设计数据库 •将下列操作映射为存储过程或触发器 –处理持久性数据的操作 –计算所包含的查询中的操作 –需要访问数据库来验证数据的操作 Student. + getTuition() + addSchedule() + getSchedule() + deleteSchedule() + hasPrerequisites() # passed()","merge.pdf_107":"deleteSchedule() + hasPrerequisites() # passed() + getNextAvailID() + getStudentID() + getName() + getAddress() 类 候选操作 •getTuition •addSchedule •getSchedule •deleteSchedule •getStudentID •getName •getAddress 课程注册系统 5.5.2 Rose中建模数据库 •正向工程 –从数据模型生成数据库 •逆向工程 –从数据库逆向生成数据模型 367 正向工程 1. 创建数据库容器； 2. 增加保存数据模型的结构(Schema)并将结构赋予数据库； 3. 在每个结构中增加表（Table）； 4. 在表中增加细节（字段、限制、触发器、索引、主键）； 5. 在表间增加关系和外键； 6. 创建视图； 7. 从数据模型创建对象模型（可选）； 8. 产生物理数据库； 9. 通过update特性让数据库与模型同步； 368 1）、创建数据库容器 •右击左边浏览器中Component View项目；","merge.pdf_108":"库与模型同步； 368 1）、创建数据库容器 •右击左边浏览器中Component View项目； •选择Data Modeler New Database； •输入数据库名； •右击浏览器中的新数据库名，并选择Open Specification； •在Target字段中选择相应DBMS类型； 369 Rose 2002 中DBMS类型 •Ansi Sql 92 •IBM DB2 5.x、6.x、7.x •IBM DB2 OS390 5.x、6.xX •Microsoft SQL Server 6.x、7.x、2000.x •Oracle 7.x、8.x •Sybase Adaptive Server 12.x 370 1 ）、创建数据库实例 371 1）、创建数据库实例 1)、创建数据库实例 373 2）、添加表空间 •使用DB2、Oracle或SQL server时，可以在数据库 中增加表空间。 •每个表空间有一个或几个物理容器，每个物理容器 是一个物理存储设备，如硬盘。 •在三种不同数据库中增加方法不一样： 374 2）、添加表空间 •Oracle –右击浏览器中数据库；","merge.pdf_109":"三种不同数据库中增加方法不一样： 374 2）、添加表空间 •Oracle –右击浏览器中数据库； –选择Data ModelerNew Tablespace； –输入表空间名； –右击浏览器中的表空间并选择Open Specification，出现 表空间规范窗口； –将表空间类型设置为Permanent（永久）或Temporary（ 临时）。 375 2、添加表空间 •DB2 –右击浏览器中数据库； –选择Data ModelerNew Tablespace； –输入表空间名； –右击浏览器中的表空间并选择Open Specification，出现 表空间规范窗口； –将表空间类型设置为Regular（正规）或Temporary（临 时）。 –设置表空间由dbms管理或由操作系统管理，前者可增加 新容器，无法扩展现有表空间，后者反之。 2）、添加表空间 •SQL server –右击浏览器中数据库； –选择Data Modeler NewTablespace； –输入表空间名； –右击浏览器中的表空间并选择Open Specification，出现 表空间规范窗口；","merge.pdf_110":"空间名； –右击浏览器中的表空间并选择Open Specification，出现 表空间规范窗口； –将表空间类型设置为Permanent（永久）或Temporary（ 临时）。 377 2）、添加表空间实例 2)、添加表空间实例 MS SQL server 缺省表 空间 379 3）、 增加结构(Schema) •结构是数据模型的容器。所有表、字段、触发器、 限制和其他数据模型元素都放在结构中。 •每个结构映射模型中的数据库。每个数据库可以包 含一个或多个结构。 380 3）、 增加结构(Schema) •右击浏览器中的LogicalView或Logical视图中的 Schemas文件夹； •选择Data Modeler New Schema； •右击浏览器中的新结构并选择Open Specification ； •选择Database下拉列表框中相应的数据库。数据库 的DBMS自动填入Target字段中。 381 3）、 增加结构实例 方法 1 方法 2 382 3）、 增加结构实例 选择前面 创建的数 据库 自动 改变 383 4）、创建数据模型图","merge.pdf_111":"382 3）、 增加结构实例 选择前面 创建的数 据库 自动 改变 383 4）、创建数据模型图 •在Schema中可以创建数据模型图（Data Model Diagram ），其中可以增加、编辑和浏览表与其他 元素。 •可以创建多个数据模型图。 •方法： a、右击浏览器中结构； b、选择Data ModelerNewData Model Diagram； c、输入新图名； d、双击打开； 384 4）、创建数据模型图 •实例 385 4）、创建数据模型图 •实例 5）、增加表（Table） 方法一： –打开数据模型图； –从工具栏中选择Table按钮； –单击图中任意位置，创建； –输入新表名； 方法二： –右击Logical View 中的结构； –选择Data ModelerNew Table； –输入新表名； 386 387 5）、增加表（Table） •实例 388 5)、增加表（Table） •实例 表工具 表 表名 389 6)、增加列（字段） •右击表并选择Open Specification； •选择规范窗口的Columns标签；","merge.pdf_112":"字段） •右击表并选择Open Specification； •选择规范窗口的Columns标签； •右击任意空白处并选择Insert； •双击新列，打开列规范化窗口； •修改列名； •选择Type标签； •选择Data Column或Computed Column(对Sql Server)； 390 6)、增加列（字段） •对Data Column，则设置属性： Domain, Data Type, Length, Precision, Scale, Unique Constraint, Primary Key, Not Null等； •对Computed Column，则设置计算列值的Sql 语句 ； •选择Check Constraints标签增加必要的限制 391 6)、增加列（字段） •实例 392 6)、增加列（字段） •实例 393 数据列 数据类型 位数 唯一性 小数位 缺省值 计算列 主键 sql 检查约束 非空 394 7)、增加索引 •打开表或Column Specification窗口； •选择Key Constraints标签； •单击New；","merge.pdf_113":"mn Specification窗口； •选择Key Constraints标签； •单击New； •将Type设置为Index •在Column列表框中，选择采用限制的列，用Add按 钮加进Key Columns列表框中； •如果索引唯一，选择Unique复选框； •在Fill Factor字段中，可选输入索引的自由空.间非分 比（１～100). 395 7)、增加索引 •实例 396 7)、增加索引 •实例 选择 Index 7)、增加索引 •实例 改名 398 8)、增加存储过程 •右击浏览器中的结构，选择Data Modeler New Stored Procedure； •Rose 创建存储过程容器，并把新存储过程放进其中 。 •右击新存储过程并选择Open Specification。 •在General标签中，设置内容：名称、语言、路径、 类型、返回类型、返回值长度、小数位数等等； •在Parameters中输入需要的参数。 399 8)、增加存储过程 •实例 400 8)、增加存储过程 •实例 401 9)、增加关系","merge.pdf_114":"。 399 8)、增加存储过程 •实例 400 8)、增加存储过程 •实例 401 9)、增加关系 •标识关系（Indentifying Relationship） –外键成为主键的一部分，子表中记录必须链接父表中记录 ；（构成聚合关系） •非标识关系（Non-indentifying Relationship） –外键不是主键的一部分，子表中记录是否链接父表中记录 由关系基数决定：基数为1则父表记录必须存在，0..1则不 需存在。（构成关联关系） 402 9、增加关系 •标识关系创建： –选择Indentifying Relationship工具栏按钮； –从父表拖放到子表； –Rose自动在子表中增加主键限制和外键限制； 403 9)、增加关系 •非标识关系创建： –选择Non-indentifying Relationship工具栏按钮； –从父表拖放到子表； –Rose自动在子表中增加外键限制； 404 10)、增加引用完整性规则 •两类引用完整性： –触发器 •在父表更新或删除时运行一个触发器 –声明式 •在外键从局中包含一个限制 405 10)、增加引用完整性规则","merge.pdf_115":"新或删除时运行一个触发器 –声明式 •在外键从局中包含一个限制 405 10)、增加引用完整性规则 •设置完整性限制的选项： –Cascade 更新或删除父表时所有子记录更新或删除； –Restrict 阻止父表更新或删除； –Set Null更新或删除父表时，将子记录中的外键设为 Null; –No Action不执行完整性限制； –Set Default更新或删除父表时，将子记录中的外键设为 默认值; 406 10)、增加引用完整性规则 •对关系设置完整性限制： –右击关系并选择Open Specification； –右击RI（完整性限制）标签； –选择Triggers或Declarative Referential Integrity单选按 钮，控制使用触发器执行或声明式完整性约束; –如果选择触发器执行完整性约束，则输入Parent Update 、Parent Delete、Child Restrict选项（阻止孤儿记录） ； –如果选择声明式完整性约束，则输入： Parent Update、 Parent Delete选项。 407 10)、增加引用完整性规则 •实例","merge.pdf_116":"nt Update、 Parent Delete选项。 407 10)、增加引用完整性规则 •实例 408 10)、增加引用完整性规则 •实例 409 10)、增加引用完整性规则 •实例 410 11)、使用视图 •在数据模型中，画出视图和源数据表之间的依赖关 系； 视图 依赖 411 11)、使用视图 •创建视图方法： –右击浏览器中的结构； –选择Data Modeler NewView; –命名新视图； –右击新视图，选择Open Specification； –在General标签中输入Name、Schema、Upateable、 Distinct、Check Option等； 412 11)、使用视图 •创建视图方法： –在Form标签中输入: •Available Members 选择视图中使用的表或视图； •Correlation Name 设置当前视图中表或视图使用的别名； •Where Clause条件字句，必须包含Where、Order By、Group By等字句。 –在Columns标签中输入:","merge.pdf_117":"句，必须包含Where、Order By、Group By等字句。 –在Columns标签中输入: •View Columns 列出视图中包括的列。要增加新列，则选Import Columns按钮再选择，Delete可以删除列； •Alias 显示列使用的别名； –在SQL标签中查看相应的SQL语句。 413 11)、使用视图 •实例 414 11)、使用视图 •实例 415 11)、使用视图 •实例 416 11)、使用视图 •实例 417 11)、使用视图 •实例 418 12)、从数据模型生成数据库 •Rose中可以选择从数据模型生成数据库或DDL脚本 。 –右击浏览器中结构或数据库，选择Data Modeler Forward Engnieer； –输入要生成的DDl文件名； –如果同时运行DDL，则选中Excute复选框，输入DBMS连 接信息。 12)、从数据模型生成数据库 方法 1 方法 2 12)、从数据模型生成数据库 •实例 420 12)、从数据模型生成数据库 •实例 421 12)、从数据模型生成数据库 •实例 422 423 12)、从数据模型生成数据库 •实例","merge.pdf_118":"421 12)、从数据模型生成数据库 •实例 422 423 12)、从数据模型生成数据库 •实例 12)、从数据模型生成数据库DDL •实例 424 CREATE TABLE s ( sno INT NOT NULL, sname VARCHAR ( 1 ) NOT NULL, age INT NOT NULL, CONSTRAINT PK_T_00 PRIMARY KEY CLUSTERED (sno) ) GO 12)、从数据模型生成数据库DDL •实例 425 CREATE TABLE j ( jno INT NOT NULL, jname VARCHAR ( 1 ), city VARCHAR ( 1 ), CONSTRAINT PK_j2 PRIMARY KEY CLUSTERED (jno) ) GO 12）、从数据模型生成数据库DDL •实例 426 CREATE TABLE p ( pno INT NOT NULL, pname VARCHAR ( 1 ), city VARCHAR ( 1 ),","merge.pdf_119":"OT NULL, pname VARCHAR ( 1 ), city VARCHAR ( 1 ), CONSTRAINT PK_p1 PRIMARY KEY CLUSTERED (pno) ) GO 12）、从数据模型生成数据库DDL •实例 427 CREATE TABLE sjp ( sno INT NOT NULL, pno INT NOT NULL, jno INT NOT NULL, pty VARCHAR ( 1 ) ) ON [PRIMARY] GO 12）、从数据模型生成数据库DDL •实例 ALTER TABLE sjp ADD CONSTRAINT FK_sjp_s FOREIGN KEY (sno) REFERENCES s (sno) GO ALTER TABLE sjp ADD CONSTRAINT FK_sjp_j FOREIGN KEY ( jno) REFERENCES j ( jno) GO ALTER TABLE sjp ADD CONSTRAINT FK_sjp_p FOREIGN KEY (pno) REFERENCES p (pno) GO","merge.pdf_120":"FK_sjp_p FOREIGN KEY (pno) REFERENCES p (pno) GO 428 429 13）、更新现有数据库 •使数据库和数据模型的变动保持同步 –右击结构选择Data Modeler Compare and Sync； –选择同步DDL或数据库，前者需输入脚本名，后者输入连 接信息； –选择同步的选项，表和限制总是同步，表和触发器等其他 元素可选； –显示模型和数据库差别，选择差别进行Import、Export、 Delete或Ignore –Next，预览改变并完成； 430 13）、更新现有数据库 •实例 431 13）、更新现有数据库 •实例 432 13）、更新现有数据库 •实例 433 13）、更新现有数据库 •实例 434 13）、更新现有数据库 •实例 435 13）、更新现有数据库 •实例 436 13）、更新现有数据库 •实例 437 13）、更新现有数据库 •实例 438 13）、更新现有数据库实例 439 13）、更新现有数据库实例 440 13）、更新现有数据库实例 Rational Rose逆向工程","merge.pdf_121":"13）、更新现有数据库实例 440 13）、更新现有数据库实例 Rational Rose逆向工程 •选择菜单Tools Data modeler Reverse Engineer，弹出Reverse Engineering Wizard窗口 ，“Next”； •选择从Database还是DDL文件逆向生成； •选择目标数据库类型和名称，建立连接； •选择结构； •选择附加项，是否转换索引、触发器、视图、存储 过程； •完成。 441 14）、Rational Rose逆向工程 442 443 14）、Rational Rose逆向工程 14）、Rational Rose逆向工程 444 14）、Rational Rose逆向工程 445 14）、Rational Rose逆向工程 446 447 14）、Rational Rose逆向工程 14）、Rational Rose逆向工程 448 14）、Rational Rose逆向工程 449 14）、Rational Rose逆向工程 450 5.6 用包图管理系统元素 •子系统 –提供行为 –完全封装 –容易替换 451","merge.pdf_122":"逆向工程 450 5.6 用包图管理系统元素 •子系统 –提供行为 –完全封装 –容易替换 451 Subsystem A <<subsystem>> Package B ClassB1 ClassB2 Client Class 包 ◦ 不提供行为 ◦ 不能完全封装 ◦ 可能容易替换 5.6 用包图管理系统元素 •提醒：类的打包 452 接口可能变化多接口变化少 功能相关的类一起打包 在独立的包中 5.7 描述运行期架构 453 描述运行期架构 补充规范 设计模型 软件架构文档 5.7 描述运行期架构 454 Layer 1 Layer 2 Layer 3 5.7 描述运行期架构 •例:架构层 455 Middleware <<layer>> Base Reuse global Application <<layer>> Business Services <<layer>> 5.7 描述运行期架构 •例：应用层 456 Registration <<layer>> Application 课程注册系统 5.7 描述运行期架构 •业务层 457 CourseCatalogSystem","merge.pdf_123":"n 课程注册系统 5.7 描述运行期架构 •业务层 457 CourseCatalogSystem <<subsystem>> External System Interfaces University Artifacts ObjectStore Support <<layer>> Business Services GUI Framework Secure Interfaces Security <<subsystem>> Security Manager BillingSystem <<subsystem>> 课程注册系统 5.7 描述运行期架构 •中间件层 458 com.odi Database (from com.odi) Session (from com.odi) Transaction (from com.odi) Map (from com.odi) java.sql ResultSet (from com.odi) Connection (from com.odi) Statement (from com.odi) DriverManager","merge.pdf_124":"m com.odi) Statement (from com.odi) DriverManager (from com.odi) <<layer>> Middleware Client/Server 架构 459 Thinner client, thicker server Database Server(s) Application Business Object Services Client A Business Object Engine Business Object Services Business Object Engine Business Object Server COM MTS Beans ETS Client B Application DCOM ADO/R CORBABeans Client C WWW Browser Web Server HTML CGI ASP Java Business Object Services Business Object Engine C/S: 三层架构（Three-Tier Architecture） 460","merge.pdf_125":"ect Engine C/S: 三层架构（Three-Tier Architecture） 460 Application Services Business Services Data Services Database Server(s) Business Object Services Business Object Engine Business Object Server COM MTS Beans ETS Client B Application DCOM ADO/R CORBABeans C/S: “Fat Client”Architecture 461 Application Services Business Services Data Services Application Business Object Services Client A Business Object Engine Database Server(s ) C/S: Web Application Architecture 462 Application Services","merge.pdf_126":"Application Architecture 462 Application Services Business Services Data Services Client C WWW Browser Web Server HTML CGI ASP Java Business Object Services Business Object Engine Database Server(s) Peer-to-Peer Architecture 463 Application Services Business Services Data Services Business Object Services Business Object Engine COM MTS Beans ETS Application DCOM ADO/R CORBABeans Business Object Services Business Object Engine COM MTS Beans ETS Application DCOM ADO/R CORBABeans 5.8 标识设计机制 •步骤","merge.pdf_127":"Application DCOM ADO/R CORBABeans 5.8 标识设计机制 •步骤 –分类设计机制 –文档化架构机制 464 5.9 用部署图建模系统安装 •Deployment diagram –部署图模仿了一个系统在运行时间内的体系结构。 它表示 了硬件元素 ( 节点 ) 的构造和软件元素是如何被映射在那 些节点之上 。 5.10.1 节点（node） •节点是存在于运行时的代表计算资源的物理元素， 可以代表一种物理硬件设备或软件元素。 •两类节点： –处理机（Processor） –设备 （Device） Processor Device Ros e RSM/RSA 5.10.1 节点（node） •处理机（Processor） –可以执行程序的硬件构件。 Processor RSM/RSA 版型 5.9.1 节点（node） •设备 （Device） –无计算能力的硬件构件。 Device RSM/RSA 版型 5.9.1 节点（node） •UML2.0中提供若干个节点原型（标准）：","merge.pdf_128":"RSM/RSA 版型 5.9.1 节点（node） •UML2.0中提供若干个节点原型（标准）： –«cdrom»， «cd-rom» ，«disk array»， «secure»， «storage» –«computer»，«pc»， «pc client»， «pc server»， «server»， «unix server»，«user pc» –它们各自的标识会显示在节点符号的右上角 5.9.2 连接 •表示两个硬件之间的关联关系，用一根实线表示。 可以象类图中一样加入角色、多重性、约束等 •为了更好地表示两个节点之间的关系，我们可以通 过“约束”来对连接进行描述。 5.9.3 部署图 •展示系统部署、网络配置、进程分发 471 <<legacy RDBMS>> Course Catalog <<Campus LAN>> <<Campus LAN>> <<Campus LAN>> <<application server>> Registration Server <<client workstation>> PC Billing System <<legacy>>","merge.pdf_129":"client workstation>> PC Billing System <<legacy>> 0..2000 1 1 1 1 1 课程注册系统 5.9.3 部署图 5.9.4 将进程分发到节点 •考虑因素 –分布模式、响应时间和系统吞吐量、最小化网络流量、节 点能力、带宽、可用的硬件 473 <<client workstation>> PC StudentApplication <<client workstation>> PC <<process>> StudentApplication <<deploy>> <<client workstation>> PC <<process>> StudentApplication 课程注册系统 5.9.4 将进程分发到节点 •例: 带进程的部署图 474 <<legacy RDBMS>> Course Catalog <<Campus LAN>> <<Campus LAN>> <<Campus LAN>> <<application server>> Registration Server <<client workstation>>","merge.pdf_130":"rver>> Registration Server <<client workstation>> PC CourseCatalogSystemAccess CourseRegistrationProcess BillingSystemAccess Billing System <<legacy>> 0..2000 1 1 1 1 1 课程注册系统 5.10 用子系统简化顺序图 •5.10.1 设计子系统和接口 –子系统可以将系统分为相对独立的部件，可以： •独立开发； •跨越分布式节点进行部署； •独立地变更； •也可以代表已有产品或者外部系统。 475 5.10.1 设计子系统和接口 476 所有其他分析类直接映射成设计类 . Analysis Design BillingSystem //submit bill() <<boundary>> Billing System <<subsystem>> IBillingSystem submitBill(forTuition : Double, forStudent : Student) CourseCatalogSystem","merge.pdf_131":"Double, forStudent : Student) CourseCatalogSystem //get course offerings() <<boundary>> Course Catalog System <<subsystem>> ICourseCatalogSystem getCourseOfferings(forSemester : Semester, forStudent : Student) : CourseOfferingList initialize() 课程注册系统 5.10.1 设计子系统和接口 477 接口开始用 “ I” 课程注册系统 5.10.1 设计子系统和接口 478 ICourseCatalogSystem <<Interface>> CloseRegistrationController + // is registration open?() + // close registration() <<control>> 0..1 +courseCatalog CourseCatalogSystem <<subsystem>>","merge.pdf_132":"+courseCatalog CourseCatalogSystem <<subsystem>> + initialize () + getCourseOfferings () + getCourseOfferings ( for Semester: Semester ) + initialize () RegistrationController + getCurrentSchedule() + deleteCurrentSchedule() + submitSchedule() + saveSchedule() + getCourseOfferings() + setSession() + <<class>> new() + getStudent() <<control>> CourseOfferingList + new() + add() 1 课程注册系统 5.10.1 设计子系统和接口 Subsystem Component Subsystem Interface ICourseCatalogSystem","merge.pdf_133":"omponent Subsystem Interface ICourseCatalogSystem getCourseOfferings(forSemester : Semester) : CourseOfferingList (from External System Interfaces) <<Interface>> 1 1 CourseOfferingList new() add() (from University Artifacts) 1 0..* CourseOffering new() setData() (from University Artifacts) <<Entity>> Statement executeQuery() executeUpdate() (from java.sql) Connection createStatement() (from java.sql) ResultSet getString() (from java.sql) DBCourseOfferring create() : CourseOffering","merge.pdf_134":".sql) DBCourseOfferring create() : CourseOffering read(searchCriteria : string) : CourseOfferingList CourseCatalogSystem getCourseOfferings(forSemester : Semester) : CourseOfferingList <<subsystem >> DriverManager getConnection(url, user, pass) : Connection (from java.sql) 课程注册系统 CourseCatalogSystem Subsystem 5.10.1 设计子系统和接口 Subsystem Interface 0..1 1 Subsystem Component StudentBillingTransaction create(forStudent : Student, forAmount : double) Student // get contact info()","merge.pdf_135":"forAmount : double) Student // get contact info() (from University Artifacts) <<Entity>> BillingSystem submitBill(forStudent : Student, forTuition : double) <<subsystem>> BillingSystemInterface submit(theTransaction : StudentBillingTransaction) IBillingSystem submitBill() (from External System Interfaces) <<Interface>> 课程注册系统 Billing System Subsystem 5.10.2 简化顺序图 •before 481 : Student : RegisterForCoursesForm: RegistrationController: Schedule: Student: CourseCatalogSystem 1.","merge.pdf_136":"roller: Schedule: Student: CourseCatalogSystem 1. // create schedule( ) 1.2. // display course offerings( ) 1.1. // get course offerings( ) 1.1.1. // get course offerings(forSemester) 1.3. // display blank schedule( ) Select Offerings Submit Schedule ref ref 课程注册系统 5.10.2 简化顺序图 •after 482 : RegisterForCoursesForm: RegistrationController: Schedule: Student: ICourseCatalogSystem 1: // create schedule 1.1: // get course offerings 1.1.1: getCourseOfferings 1.2: // display course offerings","merge.pdf_137":"tCourseOfferings 1.2: // display course offerings 1.3: // display blank schedule Select Offerings Submit Schedule ref ref 课程注册系统 5.11 用概要图建模系统扩展建模领域 •Profile diagram –概要图是一种结构图，它通过定义定制原型、标记值和约 束来描述对UML的轻量级扩展机制。配置文件允许对不同 的UML元模型进行调整： –平台，例如Java平台，企业版（Java EE）或Microsoft .NET Framework， –领域，如业务流程建模、面向服务的体系结构、医疗应用 等。 5.11 用概要图建模系统扩展建模领域 •配置文件图上使用的图形节点和边有：配置文件、 元类、原型、扩展、引用、配置文件应用程序。 工具 •RWD : Rational Web Developer –Web 页面开发工具 •RSM : Rational Software Modeler –可视化建模工具，支持UML2.0","merge.pdf_138":"RSM : Rational Software Modeler –可视化建模工具，支持UML2.0 •RAD : Rational Application Developer –前身为WSAD (Websphere Studio Application Developer) –支持J2EE 开发的IDE 环境 •RSA : Rational Software Architecture –基于Eclipse的新一代软件建模平台 谢谢 ！ UML建模技术 UML分析与建模总结 UML建模技术石秀金 488 1、业务建模（业务分析） •明确项目愿景 •涉众分析 •绘制业务用例图 •撰写业务用例规约 •使用活动图建模业务流程 2、用例建模（需求分析） •绘制用例图（图形化建模系统需求） •撰写用例规约（用文字细化系统需求） •用活动图建模业务流程 •定义词汇表（术语表) •撰写补充规约 3、用例分析（系统分析） •用协作建模用例实现 •用类图（分析级）分析对象行为 •用顺序图（分析级）建模用例行为 •用通信图（分析级）建模用例行为 •用交互纵览图细化活动细节(可选) •用计时图建模时间约束","merge.pdf_139":"行为 •用通信图（分析级）建模用例行为 •用交互纵览图细化活动细节(可选) •用计时图建模时间约束 •丰富类图(可选) •描述分析机制 4、用例设计（系统设计） •定义设计类 •用状态机图建模系统行为 •用构件图建模系统组成 •建模数据库 •用包图管理系统元素 •描述运行期架构 •标识设计机制 •用部署图建模系统安装 •用子系统简化顺序图 •类的设计 再见 ！"}